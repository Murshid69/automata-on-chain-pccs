{"language":"Solidity","sources":{"src/automata_pccs/AutomataPckDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AutomataDaoBase} from \"./shared/AutomataDaoBase.sol\";\nimport {PckDao, AttestationRequest, PcsDao, X509CRLHelper} from \"../bases/PckDao.sol\";\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\ncontract AutomataPckDao is Ownable, AutomataDaoBase, PckDao {\n    constructor(address _storage, address _pcs, address _x509, address _crl)\n        AutomataDaoBase(_storage)\n        PckDao(_pcs, _x509, _crl)\n    {\n        _initializeOwner(msg.sender);\n    }\n\n    function updateDeps(address _pcs, address _x509, address _crl) external onlyOwner {\n        Pcs = PcsDao(_pcs);\n        x509 = _x509;\n        crlLib = X509CRLHelper(_crl);\n    }\n\n    function pckSchemaID() public pure override returns (bytes32) {\n        // NOT-APPLICABLE FOR OUR USE CASE\n        // but this is required by most attestation services, such as EAS, Verax etc\n        return bytes32(0);\n    }\n\n    function tcbmSchemaID() public pure override returns (bytes32) {\n        // NOT-APPLICABLE FOR OUR USE CASE\n        // but this is required by most attestation services, such as EAS, Verax etc\n        return bytes32(0);\n    }\n\n    function _attestPck(AttestationRequest memory req, bytes32 hash)\n        internal\n        override\n        returns (bytes32 attestationId)\n    {\n        // delete the predecessor if replacing\n        _deletePredecessor(req.data.refUID);\n        _attestCollateral(hash, req.data.data);\n        attestationId = hash;\n    }\n\n    function _attestTcbm(AttestationRequest memory req) internal override returns (bytes32 attestationId) {\n        // delete the predecessor if replacing\n        _deletePredecessor(req.data.refUID);\n\n        bytes32 hash = keccak256(req.data.data);\n        _attestCollateral(hash, req.data.data);\n        attestationId = hash;\n    }\n}\n"},"src/automata_pccs/shared/AutomataDaoBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {DaoBase} from \"../../bases/DaoBase.sol\";\nimport {CA} from \"../../Common.sol\";\n\ninterface IAutomataDaoStorage {\n    function writeToPccs(bytes32 attId, bytes memory attData) external;\n\n    function readPccs(bytes32 attId) external view returns (bytes memory attData);\n\n    function deleteData(bytes32 attId) external;\n}\n\nabstract contract AutomataDaoBase is DaoBase {\n    IAutomataDaoStorage pccsStorage;\n\n    constructor(address _storage) {\n        pccsStorage = IAutomataDaoStorage(_storage);\n    }\n\n    function getAttestedData(bytes32 attestationId) public view override returns (bytes memory attestationData) {\n        attestationData = pccsStorage.readPccs(attestationId);\n    }\n\n    /// @dev we simply map the collateral hash to the data itself in our use case\n    /// @dev however, this may not be the case when the dao integrates an attestation service, such as EAS\n    /// @dev it is recommended to store the hash of the collateral as a separate attestation from the collateral\n    /// to reduce the size of data read\n    function getCollateralHash(bytes32 attestationId) public pure override returns (bytes32) {\n        return attestationId;\n    }\n\n    function _attestCollateral(bytes32 collateralHash, bytes memory data) internal {\n        pccsStorage.writeToPccs(collateralHash, data);\n    }\n\n    function _deletePredecessor(bytes32 predecessor) internal {\n        if (getAttestedData(predecessor).length > 0) {\n            pccsStorage.deleteData(predecessor);\n        }\n    }\n}\n"},"src/bases/PckDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CA, AttestationRequestData, AttestationRequest} from \"../Common.sol\";\nimport {PCKHelper, X509CertObj} from \"../helpers/PCKHelper.sol\";\nimport {X509CRLHelper, X509CRLObj} from \"../helpers/X509CRLHelper.sol\";\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\nimport {PcsDao} from \"./PcsDao.sol\";\nimport {DaoBase} from \"./DaoBase.sol\";\nimport {SigVerifyBase} from \"./SigVerifyBase.sol\";\n\n/**\n * @title Intel PCK Certificate Data Access Object\n * @notice This contract is heavily inspired by Sections 4.2.2, 4.2.4 and 4.2.8 in the Intel SGX PCCS Design Guideline\n * https://download.01.org/intel-sgx/sgx-dcap/1.19/linux/docs/SGX_DCAP_Caching_Service_Design_Guide.pdf\n * @notice This contract is the combination of both PckDao and PlatformTcbsDao as described in section 4.2\n */\nabstract contract PckDao is DaoBase, SigVerifyBase {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    error Certificate_Revoked(uint256 serialNum);\n    error Certificate_Expired();\n    error Invalid_Issuer_Name();\n    error Invalid_Subject_Name();\n    error Expired_Certificates();\n    error TCB_Mismatch();\n    error Missing_Issuer();\n    error Invalid_Signature();\n\n    string constant PCK_PLATFORM_CA_COMMON_NAME = \"Intel SGX PCK Platform CA\";\n    string constant PCK_PROCESSOR_CA_COMMON_NAME = \"Intel SGX PCK Processor CA\";\n    string constant PCK_COMMON_NAME = \"Intel SGX PCK Certificate\";\n\n    PcsDao public Pcs;\n    PCKHelper public pckLib;\n    X509CRLHelper public crlLib;\n\n    /// mapping (keccak256(qeid ++ pceid) => Enumerable tcbm Set)\n    /// tcbm is a 18-byte data which is a concatenation of PCK cpusvn (16 bytes) and pcesvn (2 bytes)\n    mapping(bytes32 => EnumerableSet.Bytes32Set) private _tcbmHSets;\n\n    /// @notice retrieves the attested TCBm from the registry\n    /// key: keccak256(qeid ++ pceid ++ platformCpuSvn ++ platformPceSvn)\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes18 tcbm\n    mapping(bytes32 => bytes32) public tcbmAttestations;\n\n    /// @notice retrieves the attested PCK Cert from the registry\n    /// key: keccak256(qeid ++ pceid ++ tcbm)\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes pckCert\n    mapping(bytes32 => bytes32) public pckCertAttestations;\n\n    /// @notice the input CA parameter can only be either PROCESSOR or PLATFORM\n    error Invalid_PCK_CA(CA ca);\n    /// @notice The corresponding PCK Certificate cannot be found for the given platform\n    error Pck_Not_Found();\n\n    modifier pckCACheck(CA ca) {\n        if (ca == CA.ROOT || ca == CA.SIGNING) {\n            revert Invalid_PCK_CA(ca);\n        }\n        _;\n    }\n\n    constructor(address _pcs, address _x509, address _crl) SigVerifyBase(_x509) {\n        Pcs = PcsDao(_pcs);\n        pckLib = PCKHelper(_x509);\n        crlLib = X509CRLHelper(_crl);\n    }\n\n    /**\n     * @notice Section 4.2.2 (getCert(qe_id, cpu_svn, pce_svn, pce_id))\n     */\n    function getCert(\n        string calldata qeid,\n        string calldata platformCpuSvn,\n        string calldata platformPceSvn,\n        string calldata pceid\n    ) external view returns (bytes memory pckCert) {\n        (bytes16 qeidBytes, bytes2 pceidBytes, bytes16 platformCpuSvnBytes, bytes2 platformPceSvnBytes,) =\n            _parseStringInputs(qeid, pceid, platformCpuSvn, platformPceSvn, \"\");\n\n        bytes32 tcbmAttestationId =\n            tcbmAttestations[_getTcbmKey(qeidBytes, pceidBytes, platformCpuSvnBytes, platformPceSvnBytes)];\n        bytes18 tcbmBytes = bytes18(getAttestedData(tcbmAttestationId));\n        bytes32 attestationId = _getPckAttestationId(qeidBytes, pceidBytes, tcbmBytes);\n        if (attestationId != bytes32(0)) {\n            pckCert = getAttestedData(attestationId);\n        }\n    }\n\n    function getCerts(string calldata qeid, string calldata pceid)\n        external\n        view\n        returns (string[] memory tcbms, bytes[] memory pckCerts)\n    {\n        (bytes16 qeidBytes, bytes2 pceidBytes,,,) = _parseStringInputs(qeid, pceid, \"\", \"\", \"\");\n\n        bytes32 k = keccak256(abi.encodePacked(qeidBytes, pceidBytes));\n        uint256 n = _tcbmHSets[k].length();\n        if (n > 0) {\n            tcbms = new string[](n);\n            pckCerts = new bytes[](n);\n            for (uint256 i = 0; i < n; i++) {\n                bytes18 tcbmBytes = bytes18(_tcbmHSets[k].at(i));\n                tcbms[i] = LibString.toHexStringNoPrefix(abi.encodePacked(tcbmBytes));\n                bytes32 attestationId = _getPckAttestationId(qeidBytes, pceidBytes, tcbmBytes);\n                pckCerts[i] = getAttestedData(attestationId);\n            }\n        }\n    }\n\n    /**\n     * @notice Modified from Section 4.2.8 (getPlatformTcbsById)\n     * @dev For simplicity's sake, the contract currently requires all the necessary parameters\n     * to return a single tcbm.\n     */\n    function getPlatformTcbByIdAndSvns(\n        string calldata qeid,\n        string calldata pceid,\n        string calldata platformCpuSvn,\n        string calldata platformPceSvn\n    ) external view returns (string memory tcbm) {\n        (bytes16 qeidBytes, bytes2 pceidBytes, bytes16 platformCpuSvnBytes, bytes2 platformPceSvnBytes,) =\n            _parseStringInputs(qeid, pceid, platformCpuSvn, platformPceSvn, \"\");\n\n        bytes32 attestationId = _getTcbmAttestationId(qeidBytes, pceidBytes, platformCpuSvnBytes, platformPceSvnBytes);\n        if (attestationId != bytes32(0)) {\n            tcbm = LibString.toHexStringNoPrefix(abi.encodePacked(bytes18(getAttestedData(attestationId))));\n        }\n    }\n\n    /**\n     * @notice Modified from Section 4.2.2 (upsertPckCert)\n     * @notice This method requires an additional CA parameter, because the on-chain PCCS does not\n     * store any data that is contained in the PLATFORMS table.\n     * @notice Therefore, there is no way to form a mapping between (qeid, pceid) to its corresponding CA.\n     * @notice Hence, it is explicitly required to be stated here.\n     * @param cert DER-encoded PCK Leaf Certificate\n     * @dev Attestation Registry Entrypoint Contracts, such as Portals on Verax are responsible\n     * @dev for performing ECDSA verification on the provided PCK Certs prior to attestations\n     */\n    function upsertPckCert(\n        CA ca,\n        string calldata qeid,\n        string calldata pceid,\n        string calldata tcbm,\n        bytes calldata cert\n    ) external pckCACheck(ca) returns (bytes32 attestationId) {\n        (bytes16 qeidBytes, bytes2 pceidBytes,,, bytes18 tcbmBytes) = _parseStringInputs(qeid, pceid, \"\", \"\", tcbm);\n        bytes32 hash = _validatePck(ca, cert, tcbmBytes, pceidBytes);\n        AttestationRequest memory req = _buildPckCertAttestationRequest(qeidBytes, pceidBytes, tcbmBytes, cert);\n        attestationId = _attestPck(req, hash);\n        pckCertAttestations[keccak256(abi.encodePacked(qeidBytes, pceidBytes, tcbmBytes))] = attestationId;\n        _upsertTcbm(qeidBytes, pceidBytes, tcbmBytes);\n    }\n\n    /// @dev currently missing strict TCB check on platformCpuSvn and platformPceSvn\n    /// @dev is recommended to overwrite this method to implement TCB check\n    function upsertPlatformTcbs(\n        string calldata qeid,\n        string calldata pceid,\n        string calldata platformCpuSvn,\n        string calldata platformPceSvn,\n        string calldata tcbm\n    ) external virtual returns (bytes32 attestationId) {\n        (\n            bytes16 qeidBytes,\n            bytes2 pceidBytes,\n            bytes16 platformCpuSvnBytes,\n            bytes2 platformPceSvnBytes,\n            bytes18 tcbmBytes\n        ) = _parseStringInputs(qeid, pceid, platformCpuSvn, platformPceSvn, tcbm);\n\n        bytes32 pckKey = keccak256(abi.encodePacked(qeidBytes, pceidBytes, tcbmBytes));\n        bytes32 pckAttestationId = pckCertAttestations[pckKey];\n\n        if (pckAttestationId == bytes32(0)) {\n            revert Pck_Not_Found();\n        }\n\n        // parse PCK to check PCEID and tcbm\n        bytes memory der = getAttestedData(pckAttestationId);\n        X509CertObj memory pck = pckLib.parseX509DER(der);\n        _validatePckTcb(pceidBytes, tcbmBytes, der, pck.extensionPtr);\n\n        AttestationRequest memory req =\n            _buildTcbmAttestationRequest(qeidBytes, pceidBytes, platformCpuSvnBytes, platformPceSvnBytes, tcbmBytes);\n        attestationId = _attestTcbm(req);\n        bytes32 tcbmKey = _getTcbmKey(qeidBytes, pceidBytes, platformCpuSvnBytes, platformPceSvnBytes);\n        tcbmAttestations[tcbmKey] = attestationId;\n    }\n\n    /**\n     * Queries PCK Certificate issuer chain for the input ca.\n     * @param ca is either CA.PROCESSOR (uint8(1)) or CA.PLATFORM ((uint8(2)))\n     * @return intermediateCert - the corresponding intermediate PCK CA (DER-encoded)\n     * @return rootCert - Intel SGX Root CA (DER-encoded)\n     */\n    function getPckCertChain(CA ca)\n        public\n        view\n        pckCACheck(ca)\n        returns (bytes memory intermediateCert, bytes memory rootCert)\n    {\n        bytes32 intermediateCertAttestationId = Pcs.pcsCertAttestations(ca);\n        bytes32 rootCertAttestationId = Pcs.pcsCertAttestations(CA.ROOT);\n        intermediateCert = getAttestedData(intermediateCertAttestationId);\n        rootCert = getAttestedData(rootCertAttestationId);\n    }\n\n    /**\n     * @dev call this method to check whether the provided pck certificate has been revoked\n     */\n    function _checkPckIsRevocable(CA ca, bytes memory pck) internal view pckCACheck(ca) returns (bool revocable) {\n        uint256 serialNumber = pckLib.getSerialNumber(pck);\n        bytes memory crlData = getAttestedData(Pcs.pcsCrlAttestations(ca));\n        revocable = crlLib.serialNumberIsRevoked(serialNumber, crlData);\n    }\n\n    /**\n     * @dev overwrite this method to define the schemaID for the attestation of PCK Certificates\n     */\n    function pckSchemaID() public view virtual returns (bytes32 PCK_SCHEMA_ID);\n\n    function tcbmSchemaID() public view virtual returns (bytes32 TCBM_SCHEMA_ID);\n\n    /**\n     * @dev implement logic to validate and attest PCK Certificates\n     * @param req structure as defined by EAS\n     * https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n     * @return attestationId\n     */\n    function _attestPck(AttestationRequest memory req, bytes32 hash) internal virtual returns (bytes32 attestationId);\n\n    /**\n     * @dev implement logic to validate and attest TCBm\n     * @param req structure as defined by EAS\n     * https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n     * @return attestationId\n     */\n    function _attestTcbm(AttestationRequest memory req) internal virtual returns (bytes32 attestationId);\n\n    /**\n     * @notice computes the key that maps to the corresponding attestation ID\n     */\n    function _getPckAttestationId(bytes16 qeid, bytes2 pceid, bytes18 tcbm)\n        private\n        view\n        returns (bytes32 attestationId)\n    {\n        attestationId = pckCertAttestations[keccak256(abi.encodePacked(qeid, pceid, tcbm))];\n    }\n\n    /**\n     * @notice computes the key that maps to the corresponding attestation ID\n     */\n    function _getTcbmAttestationId(bytes16 qeid, bytes2 pceid, bytes16 platformCpuSvn, bytes2 platformPceSvn)\n        private\n        view\n        returns (bytes32 attestationId)\n    {\n        attestationId = tcbmAttestations[_getTcbmKey(qeid, pceid, platformCpuSvn, platformPceSvn)];\n    }\n\n    /**\n     * @notice builds an EAS compliant attestation request\n     */\n    function _buildPckCertAttestationRequest(bytes16 qeid, bytes2 pceid, bytes18 tcbm, bytes calldata cert)\n        private\n        view\n        returns (AttestationRequest memory req)\n    {\n        bytes32 predecessorAttestationId = _getPckAttestationId(qeid, pceid, tcbm);\n        AttestationRequestData memory reqData = AttestationRequestData({\n            recipient: msg.sender,\n            expirationTime: 0,\n            revocable: true,\n            refUID: predecessorAttestationId,\n            data: cert,\n            value: 0\n        });\n        req = AttestationRequest({schema: pckSchemaID(), data: reqData});\n    }\n\n    function _buildTcbmAttestationRequest(\n        bytes16 qeid,\n        bytes2 pceid,\n        bytes16 platformCpuSvn,\n        bytes2 platformPceSvn,\n        bytes18 tcbm\n    ) private view returns (AttestationRequest memory req) {\n        bytes32 predecessorAttestationId = _getTcbmAttestationId(qeid, pceid, platformCpuSvn, platformPceSvn);\n        AttestationRequestData memory reqData = AttestationRequestData({\n            recipient: msg.sender,\n            expirationTime: 0, // assign zero here because this has already been checked\n            revocable: true,\n            refUID: predecessorAttestationId,\n            data: abi.encode(tcbm),\n            value: 0\n        });\n        req = AttestationRequest({schema: tcbmSchemaID(), data: reqData});\n    }\n\n    function _getTcbmKey(bytes16 qeid, bytes2 pceid, bytes16 platformCpuSvn, bytes2 platformPceSvn)\n        private\n        pure\n        returns (bytes32 key)\n    {\n        key = keccak256(abi.encodePacked(qeid, pceid, platformCpuSvn, platformPceSvn));\n    }\n\n    function _upsertTcbm(bytes16 qeid, bytes2 pceid, bytes18 tcbm) private {\n        bytes32 k = keccak256(abi.encodePacked(qeid, pceid));\n        if (!_tcbmHSets[k].contains(bytes32(tcbm))) {\n            _tcbmHSets[k].add(bytes32(tcbm));\n        }\n    }\n\n    function _validatePck(CA ca, bytes memory der, bytes18 tcbm, bytes2 pceid) private view returns (bytes32 hash) {\n        // Step 1: Check whether the pck has expired\n        bool notExpired = pckLib.certIsNotExpired(der);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        X509CertObj memory pck = pckLib.parseX509DER(der);\n        hash = keccak256(pck.tbs);\n\n        // Step 2: Check Issuer and Subject names\n        string memory expectedIssuer;\n        if (ca == CA.PLATFORM) {\n            expectedIssuer = PCK_PLATFORM_CA_COMMON_NAME;\n        } else if (ca == CA.PROCESSOR) {\n            expectedIssuer = PCK_PROCESSOR_CA_COMMON_NAME;\n        }\n        if (!LibString.eq(pck.issuerCommonName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n        if (!LibString.eq(pck.subjectCommonName, PCK_COMMON_NAME)) {\n            revert Invalid_Subject_Name();\n        }\n\n        // Step 3: validate PCEID and TCBm\n        _validatePckTcb(pceid, tcbm, der, pck.extensionPtr);\n\n        // Step 4: Check whether the pck has been revoked\n        bytes memory crlData = getAttestedData(Pcs.pcsCrlAttestations(ca));\n        if (crlData.length > 0) {\n            bool revocable = crlLib.serialNumberIsRevoked(pck.serialNumber, crlData);\n            if (revocable) {\n                revert Certificate_Revoked(pck.serialNumber);\n            }\n        }\n\n        // Step 5: Check signature\n        (bytes memory issuerCert,) = getPckCertChain(ca);\n        if (issuerCert.length > 0) {\n            bytes32 digest = sha256(pck.tbs);\n            bool sigVerified = verifySignature(digest, pck.signature, issuerCert);\n            if (!sigVerified) {\n                revert Invalid_Signature();\n            }\n        } else {\n            revert Missing_Issuer();\n        }\n    }\n\n    function _validatePckTcb(bytes2 pceid, bytes18 tcbm, bytes memory der, uint256 pckExtensionPtr) private view {\n        (uint16 pcesvn, uint8[] memory cpusvns,, bytes memory pceidBytes) =\n            pckLib.parsePckExtension(der, pckExtensionPtr);\n        bool pceidMatched = bytes2(pceidBytes) == pceid;\n        bytes memory encodedPceSvn = _littleEndianEncode(abi.encodePacked(pcesvn));\n        bytes memory encodedCpuSvn;\n        for (uint256 i = 0; i < cpusvns.length; i++) {\n            encodedCpuSvn = abi.encodePacked(encodedCpuSvn, cpusvns[i]);\n        }\n        bytes memory encodedTcbmBytes = abi.encodePacked(encodedCpuSvn, encodedPceSvn);\n        bool tcbIsValid = tcbm == bytes18(encodedTcbmBytes);\n        if (!pceidMatched || !tcbIsValid) {\n            revert TCB_Mismatch();\n        }\n    }\n\n    function _littleEndianEncode(bytes memory input) private pure returns (bytes memory encoded) {\n        uint256 n = input.length;\n        for (uint256 i = n; i > 0;) {\n            encoded = abi.encodePacked(encoded, input[i - 1]);\n            unchecked {\n                i--;\n            }\n        }\n    }\n\n    function _parseStringInputs(\n        string memory qeid,\n        string memory pceid,\n        string memory platformCpuSvn,\n        string memory platformPceSvn,\n        string memory tcbm\n    )\n        private\n        pure\n        returns (\n            bytes16 qeidBytes,\n            bytes2 pceidBytes,\n            bytes16 platformCpuSvnBytes,\n            bytes2 platformPceSvnBytes,\n            bytes18 tcbmBytes\n        )\n    {\n        if (bytes(qeid).length == 32) {\n            qeidBytes = bytes16(uint128(_parseUintFromHex(qeid)));\n        }\n        if (bytes(pceid).length == 4) {\n            pceidBytes = bytes2(uint16(_parseUintFromHex(pceid)));\n        }\n        if (bytes(platformCpuSvn).length == 32) {\n            platformCpuSvnBytes = bytes16(uint128(_parseUintFromHex(platformCpuSvn)));\n        }\n        if (bytes(platformPceSvn).length == 4) {\n            platformPceSvnBytes = bytes2(uint16(_parseUintFromHex(platformPceSvn)));\n        }\n        if (bytes(tcbm).length == 36) {\n            tcbmBytes = bytes18(uint144(_parseUintFromHex(tcbm)));\n        }\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"src/bases/DaoBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nabstract contract DaoBase {\n    /**\n     * @dev implement getter logic to retrieve attested data\n     * @param attestationId maps to the data\n     */\n    function getAttestedData(bytes32 attestationId) public view virtual returns (bytes memory attestationData);\n\n    /**\n     * @dev must store the hash of a collateral (e.g. X509 Cert, TCBInfo JSON etc) in the attestation registry\n     * @dev it is recommended to store hash as a separate attestation from the actual collateral\n     * @dev this getter can be useful for checking the correctness of the queried attested collateral\n     *\n     * @dev may link the hash attestation with the attestation of the collateral\n     * For example, the content of a hash attestation can be a tuple of bytes32 values consisting of:\n     * (bytes32 collateralHash, bytes32 collateralAttestationId)\n     * @param attestationId - the attestationId pointing to the hash attestation, or the collateral attestation\n     * itself, if the hash is included as part of the attestation data, this varies by how you define the schema.\n     */\n    function getCollateralHash(bytes32 attestationId) public view virtual returns (bytes32 collateralHash);\n\n    /// @dev https://github.com/Vectorized/solady/blob/4964e3e2da1bc86b0394f63a90821f51d60a260b/src/utils/JSONParserLib.sol#L339-L364\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number is too big for a uint256.\n    function _parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum CA {\n    ROOT,\n    PROCESSOR,\n    PLATFORM,\n    SIGNING\n}\n\n/// @notice Attestation Definition is taken from https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n/// @notice We opted for EAS Attestation Request Definition to ensure interoperability between Verax and EAS\n\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing a single attestation.\n/// https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/Common.sol#L25C1-L37C2\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n"},"src/helpers/PCKHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {X509Helper, X509CertObj, Asn1Decode, NodePtr, BytesUtils} from \"./X509Helper.sol\";\n\ncontract PCKHelper is X509Helper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    // 1.2.840.113741.1.13.1\n    bytes constant SGX_EXTENSION_OID = hex\"2A864886F84D010D01\";\n    // 1.2.840.113741.1.13.1.2\n    bytes constant TCB_OID = hex\"2A864886F84D010D0102\";\n    // 1.2.840.113741.1.13.1.2.17\n    bytes constant PCESVN_OID = hex\"2A864886F84D010D010211\";\n    // 1.2.840.113741.1.13.1.3\n    bytes constant PCEID_OID = hex\"2A864886F84D010D0103\";\n    // 1.2.840.113741.1.13.1.4\n    bytes constant FMSPC_OID = hex\"2A864886F84D010D0104\";\n\n    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\n    uint256 constant SGX_TCB_CPUSVN_SIZE = 16;\n\n    struct PCKTCBFlags {\n        bool fmspcFound;\n        bool pceidFound;\n        bool tcbFound;\n    }\n\n    // 421k gas\n    function parsePckExtension(bytes memory der, uint256 extensionPtr)\n        external\n        pure\n        returns (uint16 pcesvn, uint8[] memory cpusvns, bytes memory fmspcBytes, bytes memory pceidBytes)\n    {\n        if (der[extensionPtr.ixs()] != 0xA3) {\n            revert(\"Not an extension\");\n        }\n        uint256 parentPtr = der.firstChildOf(extensionPtr);\n        uint256 childPtr = der.firstChildOf(parentPtr);\n        bool success;\n        (success, pcesvn, cpusvns, fmspcBytes, pceidBytes) = _findPckTcbInfo(der, childPtr, parentPtr);\n        require(success, \"invalid SGX extension\");\n    }\n\n    function _findPckTcbInfo(bytes memory der, uint256 ptr, uint256 parentPtr)\n        private\n        pure\n        returns (bool success, uint16 pcesvn, uint8[] memory cpusvns, bytes memory fmspcBytes, bytes memory pceidBytes)\n    {\n        // iterate through the elements in the Extension sequence\n        // until we locate the SGX Extension OID\n        while (ptr != 0) {\n            uint256 internalPtr = der.firstChildOf(ptr);\n            if (der[internalPtr.ixs()] != 0x06) {\n                return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n            }\n\n            if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {\n                // 1.2.840.113741.1.13.1\n                internalPtr = der.nextSiblingOf(internalPtr);\n                uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);\n                uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);\n\n                // Copy flags to memory to avoid stack too deep\n                PCKTCBFlags memory flags;\n\n                while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {\n                    uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);\n                    if (der[extnValueOidPtr.ixs()] != 0x06) {\n                        return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {\n                        // 1.2.840.113741.1.13.1.2\n                        (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {\n                        // 1.2.840.113741.1.13.1.3\n                        uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);\n                        pceidBytes = der.bytesAt(pceidPtr);\n                        flags.pceidFound = true;\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {\n                        // 1.2.840.113741.1.13.1.4\n                        uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);\n                        fmspcBytes = der.bytesAt(fmspcPtr);\n                        flags.fmspcFound = true;\n                    }\n\n                    if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {\n                        extnValuePtr = der.nextSiblingOf(extnValuePtr);\n                    } else {\n                        break;\n                    }\n                }\n                success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;\n                break;\n            }\n\n            if (ptr.ixl() < parentPtr.ixl()) {\n                ptr = der.nextSiblingOf(ptr);\n            } else {\n                ptr = 0; // exit\n            }\n        }\n    }\n\n    function _findTcb(bytes memory der, uint256 oidPtr)\n        private\n        pure\n        returns (bool success, uint16 pcesvn, uint8[] memory cpusvns)\n    {\n        // sibiling of tcbOid\n        uint256 tcbPtr = der.nextSiblingOf(oidPtr);\n        // get the first svn object in the sequence\n        uint256 svnParentPtr = der.firstChildOf(tcbPtr);\n        cpusvns = new uint8[](SGX_TCB_CPUSVN_SIZE);\n        for (uint256 i = 0; i < SGX_TCB_CPUSVN_SIZE + 1; i++) {\n            uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID\n            uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value\n            bytes memory svnValueBytes = der.bytesAt(svnValuePtr);\n            uint16 svnValue =\n                svnValueBytes.length < 2 ? uint16(bytes2(svnValueBytes)) / 256 : uint16(bytes2(svnValueBytes));\n            if (BytesUtils.compareBytes(der.bytesAt(svnPtr), PCESVN_OID)) {\n                // pcesvn is 4 bytes in size\n                pcesvn = uint16(svnValue);\n            } else {\n                uint8 cpusvn = uint8(svnValue);\n                cpusvns[i] = cpusvn;\n            }\n\n            // iterate to the next svn object in the sequence\n            svnParentPtr = der.nextSiblingOf(svnParentPtr);\n        }\n        success = true;\n    }\n}\n"},"src/helpers/X509CRLHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 CRL\n * @notice This is a simplified structure of a DER-decoded X509 CRL\n */\nstruct X509CRLObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    uint256[] serialNumbersRevoked;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 CRL Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded CRLs.\n */\ncontract X509CRLHelper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    // 2.5.29.20\n    bytes constant CRL_NUMBER_OID = hex\"551d14\";\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CRL\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function crlIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function serialNumberIsRevoked(uint256 serialNumber, bytes calldata der) external pure returns (bool revoked) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        uint256[] memory ret = _getRevokedSerialNumbers(der, tbsPtr, true, serialNumber);\n        revoked = ret[0] == serialNumber;\n    }\n\n    /// x509 CRL generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. serial number\n    /// - 1b. signature algorithm\n    /// - 1c. issuer\n    /// - - 1c(a). common name\n    /// - - 1c(b). organization name\n    /// - - 1c(c). locality name\n    /// - - 1c(d). state or province name\n    /// - - 1c(e). country name\n    /// - 1d. not before\n    /// - 1e. not after\n    /// - 1f. revoked certificates\n    /// - - A list consists of revoked serial numbers and reasons.\n    /// - 1g. CRL extensions\n    /// - - 1g(a) CRL number\n    /// - - 1g(b) Authority Key Identifier\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    /// - 3a. X value\n    /// - 3b. Y value\n    function parseCRLDER(bytes calldata der) external pure returns (X509CRLObj memory crl) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        crl.serialNumber = uint256(bytes32(der.bytesAt(tbsPtr)));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (crl.validityNotBefore, crl.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.serialNumbersRevoked = _getRevokedSerialNumbers(der, tbsPtr, false, 0);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        crl.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = validityPtr;\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getRevokedSerialNumbers(bytes calldata der, uint256 revokedParentPtr, bool breakIfFound, uint256 filter)\n        private\n        pure\n        returns (uint256[] memory serialNumbers)\n    {\n        uint256 revokedPtr = der.firstChildOf(revokedParentPtr);\n\n        if (der[revokedPtr.ixs()] == 0xA0) {\n            uint256 crlExtensionPtr = der.firstChildOf(revokedPtr);\n            require(BytesUtils.compareBytes(der.bytesAt(crlExtensionPtr), CRL_NUMBER_OID), \"invalid CRL\");\n        } else {\n            bytes memory serials;\n            while (revokedPtr.ixl() <= revokedParentPtr.ixl()) {\n                uint256 serialPtr = der.firstChildOf(revokedPtr);\n                bytes memory serialBytes = der.bytesAt(serialPtr);\n                uint256 serialNumber = _parseSerialNumber(serialBytes);\n                serials = abi.encodePacked(serials, serialNumber);\n                if (breakIfFound && filter == serialNumber) {\n                    serialNumbers = new uint256[](1);\n                    serialNumbers[0] = filter;\n                    return serialNumbers;\n                }\n                revokedPtr = der.nextSiblingOf(revokedPtr);\n            }\n            uint256 count = serials.length / 32;\n            // ABI encoding format for a dynamic uint256[] value\n            serials = abi.encodePacked(abi.encode(0x20), abi.encode(count), serials);\n            serialNumbers = new uint256[](count);\n            serialNumbers = abi.decode(serials, (uint256[]));\n        }\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(sigX, sigY);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"lib/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"},"src/bases/PcsDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CA, AttestationRequestData, AttestationRequest} from \"../Common.sol\";\nimport {X509Helper, X509CertObj} from \"../helpers/X509Helper.sol\";\nimport {X509CRLHelper, X509CRLObj} from \"../helpers/X509CRLHelper.sol\";\n\nimport {DaoBase} from \"./DaoBase.sol\";\nimport {SigVerifyBase} from \"./SigVerifyBase.sol\";\n\nimport {LibString} from \"solady/utils/LibString.sol\";\n\n/**\n * @title Intel PCS Data Access Object\n * @notice This is a core contract of our on-chain PCCS implementation as it provides methods\n * @notice to read/write essential collaterals such as the RootCA, Intermediate CAs and CRLs.\n * @notice All other DAOs are expected to configure and make external calls to this contract to fetch those collaterals.\n * @notice This contract is heavily inspired by Sections 4.2.5 and 4.2.6 in the Intel SGX PCCS Design Guideline\n * https://download.01.org/intel-sgx/sgx-dcap/1.19/linux/docs/SGX_DCAP_Caching_Service_Design_Guide.pdf\n */\nabstract contract PcsDao is DaoBase, SigVerifyBase {\n    using LibString for string;\n\n    X509CRLHelper public crlLib;\n\n    /// @notice Fetches the attestationId of the attested PCS Certificate\n    ///\n    /// @dev Must ensure that the public key for the configured Intel Root CA matches with\n    /// @dev the Intel source code at: https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/39989a42bbbb0c968153a47254b6de79a27eb603/QuoteVerification/QvE/Enclave/qve.cpp#L92-L100\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes pcsCert\n    mapping(CA => bytes32) public pcsCertAttestations;\n\n    /// @notice Fetches the attestationId of the attested PCS CRLs\n    ///\n    /// @dev Verification of CRLs are conducted as part of the PCS attestation process\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes pcsCrl\n    mapping(CA => bytes32) public pcsCrlAttestations;\n\n    string constant PCK_PLATFORM_CA_COMMON_NAME = \"Intel SGX PCK Platform CA\";\n    string constant PCK_PROCESSOR_CA_COMMON_NAME = \"Intel SGX PCK Processor CA\";\n    string constant SIGNING_COMMON_NAME = \"Intel SGX TCB Signing\";\n    string constant ROOT_CA_COMMON_NAME = \"Intel SGX Root CA\";\n\n    // keccak256(hex\"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394\")\n    // the uncompressed (0x04) prefix is not included in the pubkey pre-image\n    bytes32 constant ROOT_CA_PUBKEY_HASH = 0x89f72d7c488e5b53a77c23ebcb36970ef7eb5bcf6658e9b8292cfbe4703a8473;\n\n    error Missing_Certificate(CA ca);\n    error Invalid_PCK_CA(CA ca);\n    error Invalid_Issuer_Name();\n    error Invalid_Subject_Name();\n    error Certificate_Expired();\n    error Root_Key_Mismatch();\n    error Certificate_Revoked(CA ca, uint256 serialNum);\n    error Missing_Issuer();\n    error Invalid_Signature();\n\n    constructor(address _x509, address _crl) SigVerifyBase(_x509) {\n        crlLib = X509CRLHelper(_crl);\n    }\n\n    modifier pckCACheck(CA ca) {\n        if (ca == CA.ROOT || ca == CA.SIGNING) {\n            revert Invalid_PCK_CA(ca);\n        }\n        _;\n    }\n\n    /**\n     * @param ca see {Common.sol} for definition\n     * @return cert - DER encoded certificate\n     * @return crl - DER-encoded CRLs that is signed by the provided cert\n     */\n    function getCertificateById(CA ca) external view returns (bytes memory cert, bytes memory crl) {\n        bytes32 pcsCertAttestationId = pcsCertAttestations[ca];\n        if (pcsCertAttestationId == bytes32(0)) {\n            revert Missing_Certificate(ca);\n        }\n        cert = getAttestedData(pcsCertAttestationId);\n\n        bytes32 pcsCrlAttestationId = pcsCrlAttestations[ca];\n        if (pcsCrlAttestationId != bytes32(0)) {\n            crl = getAttestedData(pcsCrlAttestationId);\n        }\n    }\n\n    /**\n     * Section 4.2.6 (upsertPcsCertificates)\n     * @param ca replaces the \"id\" value with the ca_id\n     * @param cert the DER-encoded certificate\n     */\n    function upsertPcsCertificates(CA ca, bytes calldata cert) external returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCert(ca, cert);\n        AttestationRequest memory req = _buildPcsAttestationRequest(false, ca, cert);\n        attestationId = _attestPcs(req, hash);\n        pcsCertAttestations[ca] = attestationId;\n    }\n\n    /**\n     * Section 4.2.5 (upsertPckCrl)\n     * @param ca either CA.PROCESSOR or CA.PLATFORM\n     * @param crl the DER-encoded CRL\n     */\n    function upsertPckCrl(CA ca, bytes calldata crl) external pckCACheck(ca) returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(ca, crl);\n    }\n\n    function upsertRootCACrl(bytes calldata rootcacrl) external returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(CA.ROOT, rootcacrl);\n    }\n\n    function pcsCertSchemaID() public view virtual returns (bytes32 PCS_CERT_SCHEMA_ID);\n\n    function pcsCrlSchemaID() public view virtual returns (bytes32 PCS_CRL_SCHEMA_ID);\n\n    /**\n     * @dev implement logic to validate and attest PCS Certificates or CRLs\n     * @param req structure as defined by EAS\n     * https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n     * @return attestationId\n     */\n    function _attestPcs(AttestationRequest memory req, bytes32 hash) internal virtual returns (bytes32 attestationId);\n\n    function _upsertPcsCrl(CA ca, bytes calldata crl) private returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCrl(ca, crl);\n        AttestationRequest memory req = _buildPcsAttestationRequest(true, ca, crl);\n        attestationId = _attestPcs(req, hash);\n        pcsCrlAttestations[ca] = attestationId;\n    }\n\n    /**\n     * @notice builds an EAS compliant attestation request\n     * @param isCrl - true only if the attested data is a CRL\n     * @param der - contains the DER encoded data, specified by isCrl and CA\n     */\n    function _buildPcsAttestationRequest(bool isCrl, CA ca, bytes calldata der)\n        private\n        view\n        returns (AttestationRequest memory req)\n    {\n        bytes32 predecessorAttestationId = isCrl ? pcsCrlAttestations[ca] : pcsCertAttestations[ca];\n        AttestationRequestData memory reqData = AttestationRequestData({\n            recipient: msg.sender,\n            expirationTime: 0, // assign zero here because this has already been checked\n            revocable: true,\n            refUID: predecessorAttestationId,\n            data: der,\n            value: 0\n        });\n        bytes32 schemaId = isCrl ? pcsCrlSchemaID() : pcsCertSchemaID();\n        req = AttestationRequest({schema: schemaId, data: reqData});\n    }\n\n    function _validatePcsCert(CA ca, bytes calldata cert) private view returns (bytes32 hash) {\n        X509Helper x509Lib = X509Helper(x509);\n\n        // Step 1: Check whether cert has expired\n        bool notExpired = x509Lib.certIsNotExpired(cert);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check issuer and subject common names are valid\n        string memory issuerName = x509Lib.getIssuerCommonName(cert);\n        string memory subjectName = x509Lib.getSubjectCommonName(cert);\n        string memory expectedIssuer = ROOT_CA_COMMON_NAME;\n        string memory expectedSubject;\n        if (ca == CA.PLATFORM) {\n            expectedSubject = PCK_PLATFORM_CA_COMMON_NAME;\n        } else if (ca == CA.PROCESSOR) {\n            expectedSubject = PCK_PROCESSOR_CA_COMMON_NAME;\n        } else if (ca == CA.SIGNING) {\n            expectedSubject = SIGNING_COMMON_NAME;\n        } else if (ca == CA.ROOT) {\n            expectedSubject = ROOT_CA_COMMON_NAME;\n        }\n\n        if (!LibString.eq(issuerName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n        if (!LibString.eq(subjectName, expectedSubject)) {\n            revert Invalid_Subject_Name();\n        }\n\n        // Step 3: Check Revocation Status\n        bytes memory rootCrlData = getAttestedData(pcsCrlAttestations[CA.ROOT]);\n        if (ca == CA.ROOT) {\n            bytes memory pubKey = x509Lib.getSubjectPublicKey(cert);\n            if (keccak256(pubKey) != ROOT_CA_PUBKEY_HASH) {\n                revert Root_Key_Mismatch();\n            }\n        } else if (rootCrlData.length > 0) {\n            uint256 serialNum = x509Lib.getSerialNumber(cert);\n            bool revoked = crlLib.serialNumberIsRevoked(serialNum, rootCrlData);\n            if (revoked) {\n                revert Certificate_Revoked(ca, serialNum);\n            }\n        }\n\n        // Step 4: Check signature\n        bytes memory rootCert = _getIssuer(CA.ROOT);\n        (bytes memory tbs, bytes memory signature) = x509Lib.getTbsAndSig(cert);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified;\n        if (ca == CA.ROOT) {\n            // the root certificate is issued by its own key\n            sigVerified = verifySignature(digest, signature, cert);\n        } else if (rootCert.length > 0) {\n            sigVerified = verifySignature(digest, signature, rootCert);\n        } else {\n            // all other certificates should already have an iusuer configured\n            revert Missing_Issuer();\n        }\n\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _validatePcsCrl(CA ca, bytes calldata crl) private view returns (bytes32 hash) {\n        // Step 1: Check whether CRL has expired\n        bool notExpired = crlLib.crlIsNotExpired(crl);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check CRL issuer\n        string memory issuerCommonName = crlLib.getIssuerCommonName(crl);\n        string memory expectedIssuer;\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            expectedIssuer = ca == CA.PLATFORM ? PCK_PLATFORM_CA_COMMON_NAME : PCK_PROCESSOR_CA_COMMON_NAME;\n        } else {\n            expectedIssuer = ROOT_CA_COMMON_NAME;\n        }\n        if (!LibString.eq(issuerCommonName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n\n        // Step 3: Verify signature\n        (bytes memory tbs, bytes memory signature) = crlLib.getTbsAndSig(crl);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified = verifySignature(digest, signature, _getIssuer(ca));\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _getIssuer(CA ca) private view returns (bytes memory issuerCert) {\n        bytes32 intermediateCertAttestationId = pcsCertAttestations[ca];\n        bytes32 rootCertAttestationId = pcsCertAttestations[CA.ROOT];\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            // this is applicable to crls only\n            // since all certs in the pcsdao are issued by the root\n            issuerCert = getAttestedData(intermediateCertAttestationId);\n        } else {\n            issuerCert = getAttestedData(rootCertAttestationId);\n        }\n    }\n}\n"},"src/bases/SigVerifyBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {P256Verifier} from \"../utils/P256Verifier.sol\";\n\ninterface IX509 {\n    function getSubjectPublicKey(bytes memory der) external pure returns (bytes memory pubKey);\n}\n\nabstract contract SigVerifyBase {\n    address public x509;\n\n    using BytesUtils for bytes;\n\n    constructor(address _x509helper) {\n        x509 = _x509helper;\n    }\n\n    function verifySignature(bytes32 digest, bytes memory signature, bytes memory signingCertBlob)\n        internal\n        view\n        returns (bool verified)\n    {\n        if (signature.length != 64) {\n            return false;\n        }\n\n        bytes memory pubKey = IX509(x509).getSubjectPublicKey(signingCertBlob);\n        if (pubKey.length != 64) {\n            return false;\n        }\n\n        verified = P256Verifier.ecdsaVerify(digest, signature, pubKey);\n    }\n}\n"},"src/helpers/X509Helper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 Certificates\n * @notice This is a simplified structure of a DER-decoded X509 Certificate\n */\nstruct X509CertObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    string subjectCommonName;\n    bytes subjectPublicKey;\n    // the extension needs to be parsed further for PCK Certificates\n    uint256 extensionPtr;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 Certificates Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded X509 certificates.\n * @dev The Extension sequence in Intel PCK Certificates is a custom ASN.1 Sequence that needs to be\n * @dev parsed further in a more specialized PCKHelper contract.\n */\ncontract X509Helper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CERTIFICATE\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function certIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function getSubjectCommonName(bytes calldata der) external pure returns (string memory subjectCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function getSubjectPublicKey(bytes calldata der) external pure returns (bytes memory pubKey) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        pubKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n    }\n\n    /// x509 Certificates generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. version\n    /// - 1b. serial number\n    /// - 1c. siganture algorithm\n    /// - 1d. issuer\n    /// - - 1d(a). common name\n    /// - - 1d(b). organization name\n    /// - - 1d(c). locality name\n    /// - - 1d(d). state or province name\n    /// - - 1d(e). country name\n    /// - 1e. validity\n    /// - - 1e(a) notBefore\n    /// - - 1e(b) notAfter\n    /// - 1f. subject\n    /// - - contains the same set of elements as 1d\n    /// - 1g. subject public key info\n    /// - - 1g(a). algorithm\n    /// - - 1g(b). subject public key\n    /// - 1h. Extensions\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    /// - 3a. X value\n    /// - 3b. Y value\n    function parseX509DER(bytes calldata der) external pure returns (X509CertObj memory cert) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        cert.tbs = der.allBytesAt(tbsParentPtr);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.serialNumber = _parseSerialNumber(der.bytesAt(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (cert.validityNotBefore, cert.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        cert.subjectPublicKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n\n        cert.extensionPtr = der.nextSiblingOf(tbsPtr);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        cert.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = der.firstChildOf(validityPtr);\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getSubjectPublicKey(bytes calldata der, uint256 subjectPublicKeyInfoPtr)\n        private\n        pure\n        returns (bytes memory pubKey)\n    {\n        subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);\n        pubKey = der.bitstringAt(subjectPublicKeyInfoPtr);\n        if (pubKey.length != 65) {\n            // TODO: we need to figure out how to handle key with prefix byte 0x02 or 0x03\n            revert(\"compressed public key not supported\");\n        }\n        pubKey = _trimBytes(pubKey, 64);\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(sigX, sigY);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"},"src/utils/Asn1Decode.sol":{"content":"// SPDX-License-Identifier: MIT\n// Original source: https://github.com/JonahGroendal/asn1-decode\npragma solidity ^0.8.0;\n\n// Inspired by PufferFinance/rave - Apache-2.0 license\n// https://github.com/JonahGroendal/asn1-decode/blob/5c2d1469fc678513753786acb441e597969192ec/contracts/Asn1Decode.sol\n\nimport \"./BytesUtils.sol\";\n\nlibrary NodePtr {\n    // Unpack first byte index\n    function ixs(uint256 self) internal pure returns (uint256) {\n        return uint80(self);\n    }\n    // Unpack first content byte index\n\n    function ixf(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 80);\n    }\n    // Unpack last content byte index\n\n    function ixl(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 160);\n    }\n    // Pack 3 uint80s into a uint256\n\n    function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {\n        _ixs |= _ixf << 80;\n        _ixs |= _ixl << 160;\n        return _ixs;\n    }\n}\n\nlibrary Asn1Decode {\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /*\n    * @dev Get the root node. First step in traversing an ASN1 structure\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function root(bytes memory der) internal pure returns (uint256) {\n        return readNodeLength(der, 0);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within a bit string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        return readNodeLength(der, ptr.ixf() + 1);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within an octet string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x04, \"Not type OCTET STRING\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Get the next sibling node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the next sibling node\n    */\n    function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        return readNodeLength(der, ptr.ixl() + 1);\n    }\n\n    /*\n    * @dev Get the first child node of the current node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the first child node\n    */\n    function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] & 0x20 == 0x20, \"Not a constructed type\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Use for looping through children of a node (either i or j).\n    * @param i Pointer to an ASN1 node\n    * @param j Pointer to another ASN1 node of the same ASN1 structure\n    * @return True iff j is child of i or i is child of j.\n    */\n    function isChildOf(uint256 i, uint256 j) internal pure returns (bool) {\n        return (((i.ixf() <= j.ixs()) && (j.ixl() <= i.ixl())) || ((j.ixf() <= i.ixs()) && (i.ixl() <= j.ixl())));\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node\n    */\n    function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract entire node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return All bytes of node\n    */\n    function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node as bytes32\n    */\n    function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.readBytesN(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Uint value of node\n    */\n    function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 len = ptr.ixl() + 1 - ptr.ixf();\n        return uint256(der.readBytesN(ptr.ixf(), len) >> (32 - len) * 8);\n    }\n\n    /*\n    * @dev Extract value of a positive integer node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of a positive integer node\n    */\n    function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        if (der[ptr.ixf()] == 0) {\n            return der.substring(ptr.ixf() + 1, valueLength - 1);\n        } else {\n            return der.substring(ptr.ixf(), valueLength);\n        }\n    }\n\n    function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of bitstring node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value of bitstring converted to bytes\n    */\n    function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        // Only 00 padded bitstr can be converted to bytestr!\n        require(der[ptr.ixf()] == 0x00);\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        return der.substring(ptr.ixf() + 1, valueLength - 1);\n    }\n\n    function readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {\n        uint256 length;\n        uint80 ixFirstContentByte;\n        uint80 ixLastContentByte;\n        if ((der[ix + 1] & 0x80) == 0) {\n            length = uint8(der[ix + 1]);\n            ixFirstContentByte = uint80(ix + 2);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        } else {\n            uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F);\n            if (lengthbytesLength == 1) {\n                length = der.readUint8(ix + 2);\n            } else if (lengthbytesLength == 2) {\n                length = der.readUint16(ix + 2);\n            } else {\n                length = uint256(der.readBytesN(ix + 2, lengthbytesLength) >> (32 - lengthbytesLength) * 8);\n            }\n            ixFirstContentByte = uint80(ix + 2 + lengthbytesLength);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        }\n        return NodePtr.getPtr(ix, ixFirstContentByte, ixLastContentByte);\n    }\n}\n"},"src/utils/BytesUtils.sol":{"content":"// SPDX-License-Identifier: BSD 2-Clause License\npragma solidity ^0.8.0;\n\n// Inspired by ensdomains/dnssec-oracle - BSD-2-Clause license\n// https://github.com/ensdomains/dnssec-oracle/blob/master/contracts/BytesUtils.sol\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        uint256 shortest = len;\n        if (otherlen < len) {\n            shortest = otherlen;\n        }\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max; // aka 0xffffff....\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0) {\n                    return int256(diff);\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset, uint256 len)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns (bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret :=\n                and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint256 idx, uint256 len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask;\n        if (len == 0) {\n            mask = type(uint256).max; // Set to maximum value of uint256\n        } else {\n            mask = 256 ** (32 - len) - 1;\n        }\n\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint256 off, uint256 len) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {\n        if (a.length != b.length) {\n            return false;\n        }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},"src/utils/DateTimeUtils.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport {DateTimeLib} from \"solady/utils/DateTimeLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\nlibrary DateTimeUtils {\n    using LibString for string;\n\n    /*\n     * @dev Convert a DER-encoded time to a unix timestamp\n     * @param x509Time The DER-encoded time\n     * @return The unix timestamp\n     */\n    function fromDERToTimestamp(bytes memory x509Time) internal pure returns (uint256) {\n        uint16 yrs;\n        uint8 mnths;\n        uint8 dys;\n        uint8 hrs;\n        uint8 mins;\n        uint8 secs;\n        uint8 offset;\n\n        if (x509Time.length == 13) {\n            if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;\n            else yrs += 1900;\n        } else {\n            yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;\n            offset = 2;\n        }\n        yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48;\n        mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;\n        dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;\n        hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;\n        mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;\n        secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;\n\n        return DateTimeLib.dateTimeToTimestamp(yrs, mnths, dys, hrs, mins, secs);\n    }\n\n    /// @dev iso follows pattern: \"YYYY-MM-DDTHH:mm:ssZ\"\n    function fromISOToTimestamp(string memory iso) internal pure returns (uint256) {\n        require(bytes(iso).length == 20, \"invalid iso string length\");\n        uint256 y = stringToUint(iso.slice(0, 4));\n        uint256 m = stringToUint(iso.slice(5, 7));\n        uint256 d = stringToUint(iso.slice(8, 10));\n        uint256 h = stringToUint(iso.slice(11, 13));\n        uint256 min = stringToUint(iso.slice(14, 16));\n        uint256 s = stringToUint(iso.slice(17, 19));\n\n        return DateTimeLib.dateTimeToTimestamp(y, m, d, h, min, s);\n    }\n\n    // https://ethereum.stackexchange.com/questions/10932/how-to-convert-string-to-int\n    function stringToUint(string memory s) private pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 c = uint256(uint8(b[i]));\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n}\n"},"src/utils/P256Verifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BytesUtils.sol\";\n\n/**\n * @notice modified from https://github.com/daimo-eth/p256-verifier/\n */\nlibrary P256Verifier {\n    using BytesUtils for bytes;\n\n    address internal constant P256_VERIFIER = 0xc2b78104907F722DABAc4C69f826a522B2754De4;\n\n    function ecdsaVerify(bytes32 messageHash, bytes memory signature, bytes memory key)\n        internal\n        view\n        returns (bool verified)\n    {\n        bytes memory args = abi.encode(\n            messageHash,\n            uint256(bytes32(signature.substring(0, 32))),\n            uint256(bytes32(signature.substring(32, 32))),\n            uint256(bytes32(key.substring(0, 32))),\n            uint256(bytes32(key.substring(32, 32)))\n        );\n        (bool success, bytes memory ret) = P256_VERIFIER.staticcall(args);\n        assert(success); // never reverts, always returns 0 or 1\n\n        verified = abi.decode(ret, (uint256)) == 1;\n    }\n}\n"},"lib/solady/src/utils/DateTimeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n///\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Weekdays are 1-indexed for a traditional rustic feel.\n\n    // \"And on the seventh day God finished his work that he had done,\n    // and he rested on the seventh day from all his work that he had done.\"\n    // -- Genesis 2:2\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed for ease of use.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1F1C1F1E1F1E1F1F1E1F1E1F)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(add(month, w), 12), lt(add(day, w), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n"}},"settings":{"remappings":["solady/=lib/solady/src/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":999999},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
