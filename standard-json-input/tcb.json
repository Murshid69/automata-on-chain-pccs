{"language":"Solidity","sources":{"src/automata_pccs/AutomataFmspcTcbDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AutomataDaoBase} from \"./shared/AutomataDaoBase.sol\";\nimport {FmspcTcbDao, AttestationRequest, PcsDao} from \"../bases/FmspcTcbDao.sol\";\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\ncontract AutomataFmspcTcbDao is Ownable, AutomataDaoBase, FmspcTcbDao {\n    constructor(address _storage, address _pcs, address _fmspcHelper, address _x509Helper)\n        AutomataDaoBase(_storage)\n        FmspcTcbDao(_pcs, _fmspcHelper, _x509Helper)\n    {\n        _initializeOwner(msg.sender);\n    }\n\n    function setPcs(address _pcs) external onlyOwner {\n        Pcs = PcsDao(_pcs);\n    }\n\n    function fmpscTcbV2SchemaID() public pure override returns (bytes32) {\n        // NOT-APPLICABLE FOR OUR USE CASE\n        // but this is required by most attestation services, such as EAS, Verax etc\n        return bytes32(0);\n    }\n\n    function fmpscTcbV3SchemaID() public pure override returns (bytes32) {\n        // NOT-APPLICABLE FOR OUR USE CASE\n        // but this is required by most attestation services, such as EAS, Verax etc\n        return bytes32(0);\n    }\n\n    function _attestTcb(AttestationRequest memory req, bytes32 hash)\n        internal\n        override\n        returns (bytes32 attestationId)\n    {\n        // delete the predecessor if replacing\n        _deletePredecessor(req.data.refUID);\n        _attestCollateral(hash, req.data.data);\n        attestationId = hash;\n    }\n}\n"},"src/automata_pccs/shared/AutomataDaoBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {DaoBase} from \"../../bases/DaoBase.sol\";\nimport {CA} from \"../../Common.sol\";\n\ninterface IAutomataDaoStorage {\n    function writeToPccs(bytes32 attId, bytes memory attData) external;\n\n    function readPccs(bytes32 attId) external view returns (bytes memory attData);\n\n    function deleteData(bytes32 attId) external;\n}\n\nabstract contract AutomataDaoBase is DaoBase {\n    IAutomataDaoStorage pccsStorage;\n\n    constructor(address _storage) {\n        pccsStorage = IAutomataDaoStorage(_storage);\n    }\n\n    function getAttestedData(bytes32 attestationId) public view override returns (bytes memory attestationData) {\n        attestationData = pccsStorage.readPccs(attestationId);\n    }\n\n    /// @dev we simply map the collateral hash to the data itself in our use case\n    /// @dev however, this may not be the case when the dao integrates an attestation service, such as EAS\n    /// @dev it is recommended to store the hash of the collateral as a separate attestation from the collateral\n    /// to reduce the size of data read\n    function getCollateralHash(bytes32 attestationId) public pure override returns (bytes32) {\n        return attestationId;\n    }\n\n    function _attestCollateral(bytes32 collateralHash, bytes memory data) internal {\n        pccsStorage.writeToPccs(collateralHash, data);\n    }\n\n    function _deletePredecessor(bytes32 predecessor) internal {\n        if (getAttestedData(predecessor).length > 0) {\n            pccsStorage.deleteData(predecessor);\n        }\n    }\n}\n"},"src/bases/FmspcTcbDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PcsDao} from \"./PcsDao.sol\";\nimport {DaoBase} from \"./DaoBase.sol\";\nimport {SigVerifyBase} from \"./SigVerifyBase.sol\";\n\nimport {CA, AttestationRequestData, AttestationRequest} from \"../Common.sol\";\nimport {\n    FmspcTcbHelper,\n    TcbInfoJsonObj,\n    TcbId,\n    TcbInfoBasic,\n    TCBLevelsObj,\n    TDXModule,\n    TDXModuleIdentity\n} from \"../helpers/FmspcTcbHelper.sol\";\n\n/**\n * @title FMSPC TCB Data Access Object\n * @notice This contract is heavily inspired by Section 4.2.3 in the Intel SGX PCCS Design Guidelines\n * https://download.01.org/intel-sgx/sgx-dcap/1.19/linux/docs/SGX_DCAP_Caching_Service_Design_Guide.pdf\n * @dev should extends this contract and use the provided read/write methods to interact with TCBInfo JSON\n * data published on-chain.\n */\nabstract contract FmspcTcbDao is DaoBase, SigVerifyBase {\n    PcsDao public Pcs;\n    FmspcTcbHelper public FmspcTcbLib;\n\n    /// @notice retrieves the attestationId of the attested FMSPC TCBInfo from the registry\n    /// key: keccak256(type ++ FMSPC ++ version)\n    /// @notice the schema of the attested data is dependent on the version of TCBInfo:\n    /// For TCBInfoV2, it consists of the ABI-encoded tuple of:\n    /// (TcbInfoBasic, TCBLevelsObj[], string tcbInfo, bytes signature)\n    /// For TCBInfoV3, it consists of the abi-encoded tuple of:\n    /// (TcbInfoBasic, TDXModule, TDXModuleIdentity[], TCBLevelsObj, string tcbInfo, bytes signature)\n    /// See {{ FmspcTcbHelper.sol }} to learn more about FMSPC TCB related struct definitions.\n    mapping(bytes32 => bytes32) public fmspcTcbInfoAttestations;\n\n    constructor(address _pcs, address _fmspcHelper, address _x509Helper) SigVerifyBase(_x509Helper) {\n        Pcs = PcsDao(_pcs);\n        FmspcTcbLib = FmspcTcbHelper(_fmspcHelper);\n    }\n\n    error Invalid_TCB_Cert_Signature();\n    error TCB_Expired();\n\n    /**\n     * @dev overwrite this method to define the schemaID for the attestation of TCBInfo\n     */\n    function fmpscTcbV2SchemaID() public view virtual returns (bytes32 FMSPC_TCB_V2_SCHEMA_ID);\n\n    /**\n     * @dev overwrite this method to define the schemaID for the attestation of TCBInfo\n     */\n    function fmpscTcbV3SchemaID() public view virtual returns (bytes32 FMSPC_TCB_V3_SCHEMA_ID);\n\n    /**\n     * @dev implement logic to validate and attest TCBInfo\n     * @param req structure as defined by EAS\n     * https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n     * @return attestationId\n     */\n    function _attestTcb(AttestationRequest memory req, bytes32 hash) internal virtual returns (bytes32 attestationId);\n\n    /**\n     * @notice Section 4.2.3 (getTcbInfo)\n     * @notice Queries TCB Info for the given FMSPC\n     * @param tcbType 0: SGX, 1: TDX\n     * https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/39989a42bbbb0c968153a47254b6de79a27eb603/QuoteVerification/QVL/Src/AttestationParsers/src/Json/TcbInfo.cpp#L46-L47\n     * @param fmspc FMSPC\n     * @param version v2 or v3\n     * https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/39989a42bbbb0c968153a47254b6de79a27eb603/QuoteVerification/QVL/Src/AttestationParsers/include/SgxEcdsaAttestation/AttestationParsers.h#L241-L248\n     * @return tcbObj See {FmspcTcbHelper.sol} to learn more about the structure definition\n     */\n    function getTcbInfo(uint256 tcbType, string calldata fmspc, uint256 version)\n        external\n        view\n        returns (TcbInfoJsonObj memory tcbObj)\n    {\n        bytes6 fmspcBytes = bytes6(uint48(_parseUintFromHex(fmspc)));\n        bytes32 attestationId = _getAttestationId(tcbType, fmspcBytes, version);\n        if (attestationId != bytes32(0)) {\n            bytes memory attestedTcbData = getAttestedData(attestationId);\n            if (version < 3) {\n                (,, tcbObj.tcbInfoStr, tcbObj.signature) =\n                    abi.decode(attestedTcbData, (TcbInfoBasic, TCBLevelsObj[], string, bytes));\n            } else {\n                (,,,, tcbObj.tcbInfoStr, tcbObj.signature) = abi.decode(\n                    attestedTcbData, (TcbInfoBasic, TDXModule, TDXModuleIdentity[], TCBLevelsObj[], string, bytes)\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Section 4.2.9 (upsertEnclaveIdentity)\n     * @dev Attestation Registry Entrypoint Contracts, such as Portals on Verax are responsible\n     * @dev for performing ECDSA verification on the provided TCBInfo\n     * against the Signing CA key prior to attestations\n     * @param tcbInfoObj See {FmspcTcbHelper.sol} to learn more about the structure definition\n     */\n    function upsertFmspcTcb(TcbInfoJsonObj calldata tcbInfoObj) external returns (bytes32 attestationId) {\n        _validateTcbInfo(tcbInfoObj);\n        (AttestationRequest memory req, TcbInfoBasic memory tcbInfo) = _buildTcbAttestationRequest(tcbInfoObj);\n        bytes32 hash = sha256(bytes(tcbInfoObj.tcbInfoStr));\n        attestationId = _attestTcb(req, hash);\n        fmspcTcbInfoAttestations[keccak256(abi.encodePacked(uint8(tcbInfo.id), tcbInfo.fmspc, tcbInfo.version))] =\n            attestationId;\n    }\n\n    /**\n     * @notice Fetches the TCBInfo Issuer Chain\n     * @return signingCert - DER encoded Intel TCB Signing Certificate\n     * @return rootCert - DER encoded Intel SGX Root CA\n     */\n    function getTcbIssuerChain() public view returns (bytes memory signingCert, bytes memory rootCert) {\n        bytes32 signingCertAttestationId = Pcs.pcsCertAttestations(CA.SIGNING);\n        bytes32 rootCertAttestationId = Pcs.pcsCertAttestations(CA.ROOT);\n        signingCert = getAttestedData(signingCertAttestationId);\n        rootCert = getAttestedData(rootCertAttestationId);\n    }\n\n    /**\n     * @notice computes the key that maps to the corresponding attestation ID\n     * @dev once again I am reminding you that the argument tcbType is to indicate the TEE type for the\n     * particular TCBInfo. i.e. 0: SGX, 1: TDX\n     */\n    function _getAttestationId(uint256 tcbType, bytes6 fmspc, uint256 version)\n        private\n        view\n        returns (bytes32 attestationId)\n    {\n        attestationId = fmspcTcbInfoAttestations[keccak256(abi.encodePacked(uint8(tcbType), fmspc, uint32(version)))];\n    }\n\n    /**\n     * @notice builds an EAS compliant attestation request\n     */\n    function _buildTcbAttestationRequest(TcbInfoJsonObj calldata tcbInfoObj)\n        private\n        view\n        returns (AttestationRequest memory req, TcbInfoBasic memory tcbInfo)\n    {\n        bytes memory attestationData;\n        (attestationData, tcbInfo) = _buildAttestationData(tcbInfoObj.tcbInfoStr, tcbInfoObj.signature);\n        bytes32 predecessorAttestationId = _getAttestationId(uint8(tcbInfo.id), tcbInfo.fmspc, tcbInfo.version);\n        if (block.timestamp < tcbInfo.issueDate || block.timestamp > tcbInfo.nextUpdate) {\n            revert TCB_Expired();\n        }\n        AttestationRequestData memory reqData = AttestationRequestData({\n            recipient: msg.sender,\n            expirationTime: uint64(tcbInfo.nextUpdate),\n            revocable: true,\n            refUID: predecessorAttestationId,\n            data: attestationData,\n            value: 0\n        });\n        bytes32 schemaId = tcbInfo.version < 3 ? fmpscTcbV2SchemaID() : fmpscTcbV3SchemaID();\n        req = AttestationRequest({schema: schemaId, data: reqData});\n    }\n\n    function _buildAttestationData(string memory tcbInfoStr, bytes memory signature)\n        private\n        view\n        returns (bytes memory attestationData, TcbInfoBasic memory tcbInfo)\n    {\n        (, TCBLevelsObj[] memory tcbLevels) = FmspcTcbLib.parseTcbLevels(tcbInfoStr);\n        tcbInfo = FmspcTcbLib.parseTcbString(tcbInfoStr);\n        if (tcbInfo.version < 3) {\n            attestationData = abi.encode(tcbInfo, tcbLevels, tcbInfoStr, signature);\n        } else {\n            TDXModule memory module;\n            TDXModuleIdentity[] memory moduleIdentities;\n            if (tcbInfo.id == TcbId.TDX) {\n                (module, moduleIdentities) = FmspcTcbLib.parseTcbTdxModules(tcbInfoStr);\n            }\n            attestationData = abi.encode(tcbInfo, module, moduleIdentities, tcbLevels, tcbInfoStr, signature);\n        }\n    }\n\n    function _validateTcbInfo(TcbInfoJsonObj calldata tcbInfoObj) private view {\n        // Get TCB Signing Cert\n        bytes32 tcbSigningAttestationId = Pcs.pcsCertAttestations(CA.SIGNING);\n        bytes memory signingDer = getAttestedData(tcbSigningAttestationId);\n\n        // Validate signature\n        bool sigVerified = verifySignature(sha256(bytes(tcbInfoObj.tcbInfoStr)), tcbInfoObj.signature, signingDer);\n\n        if (!sigVerified) {\n            revert Invalid_TCB_Cert_Signature();\n        }\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"src/bases/DaoBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nabstract contract DaoBase {\n    /**\n     * @dev implement getter logic to retrieve attested data\n     * @param attestationId maps to the data\n     */\n    function getAttestedData(bytes32 attestationId) public view virtual returns (bytes memory attestationData);\n\n    /**\n     * @dev must store the hash of a collateral (e.g. X509 Cert, TCBInfo JSON etc) in the attestation registry\n     * @dev it is recommended to store hash as a separate attestation from the actual collateral\n     * @dev this getter can be useful for checking the correctness of the queried attested collateral\n     *\n     * @dev may link the hash attestation with the attestation of the collateral\n     * For example, the content of a hash attestation can be a tuple of bytes32 values consisting of:\n     * (bytes32 collateralHash, bytes32 collateralAttestationId)\n     * @param attestationId - the attestationId pointing to the hash attestation, or the collateral attestation\n     * itself, if the hash is included as part of the attestation data, this varies by how you define the schema.\n     */\n    function getCollateralHash(bytes32 attestationId) public view virtual returns (bytes32 collateralHash);\n\n    /// @dev https://github.com/Vectorized/solady/blob/4964e3e2da1bc86b0394f63a90821f51d60a260b/src/utils/JSONParserLib.sol#L339-L364\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number is too big for a uint256.\n    function _parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum CA {\n    ROOT,\n    PROCESSOR,\n    PLATFORM,\n    SIGNING\n}\n\n/// @notice Attestation Definition is taken from https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n/// @notice We opted for EAS Attestation Request Definition to ensure interoperability between Verax and EAS\n\nstruct AttestationRequestData {\n    address recipient; // The recipient of the attestation.\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    bool revocable; // Whether the attestation is revocable.\n    bytes32 refUID; // The UID of the related attestation.\n    bytes data; // Custom attestation data.\n    uint256 value; // An explicit ETH amount to send to the resolver. This is important to prevent accidental user errors.\n}\n\nstruct AttestationRequest {\n    bytes32 schema; // The unique identifier of the schema.\n    AttestationRequestData data; // The arguments of the attestation request.\n}\n\n/// @notice A struct representing a single attestation.\n/// https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/Common.sol#L25C1-L37C2\nstruct Attestation {\n    bytes32 uid; // A unique identifier of the attestation.\n    bytes32 schema; // The unique identifier of the schema.\n    uint64 time; // The time when the attestation was created (Unix timestamp).\n    uint64 expirationTime; // The time when the attestation expires (Unix timestamp).\n    uint64 revocationTime; // The time when the attestation was revoked (Unix timestamp).\n    bytes32 refUID; // The UID of the related attestation.\n    address recipient; // The recipient of the attestation.\n    address attester; // The attester/sender of the attestation.\n    bool revocable; // Whether the attestation is revocable.\n    bytes data; // Custom attestation data.\n}\n"},"src/bases/PcsDao.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CA, AttestationRequestData, AttestationRequest} from \"../Common.sol\";\nimport {X509Helper, X509CertObj} from \"../helpers/X509Helper.sol\";\nimport {X509CRLHelper, X509CRLObj} from \"../helpers/X509CRLHelper.sol\";\n\nimport {DaoBase} from \"./DaoBase.sol\";\nimport {SigVerifyBase} from \"./SigVerifyBase.sol\";\n\nimport {LibString} from \"solady/utils/LibString.sol\";\n\n/**\n * @title Intel PCS Data Access Object\n * @notice This is a core contract of our on-chain PCCS implementation as it provides methods\n * @notice to read/write essential collaterals such as the RootCA, Intermediate CAs and CRLs.\n * @notice All other DAOs are expected to configure and make external calls to this contract to fetch those collaterals.\n * @notice This contract is heavily inspired by Sections 4.2.5 and 4.2.6 in the Intel SGX PCCS Design Guideline\n * https://download.01.org/intel-sgx/sgx-dcap/1.19/linux/docs/SGX_DCAP_Caching_Service_Design_Guide.pdf\n */\nabstract contract PcsDao is DaoBase, SigVerifyBase {\n    using LibString for string;\n\n    X509CRLHelper public crlLib;\n\n    /// @notice Fetches the attestationId of the attested PCS Certificate\n    ///\n    /// @dev Must ensure that the public key for the configured Intel Root CA matches with\n    /// @dev the Intel source code at: https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/39989a42bbbb0c968153a47254b6de79a27eb603/QuoteVerification/QvE/Enclave/qve.cpp#L92-L100\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes pcsCert\n    mapping(CA => bytes32) public pcsCertAttestations;\n\n    /// @notice Fetches the attestationId of the attested PCS CRLs\n    ///\n    /// @dev Verification of CRLs are conducted as part of the PCS attestation process\n    ///\n    /// @notice the schema of the attested data is the following:\n    /// - bytes pcsCrl\n    mapping(CA => bytes32) public pcsCrlAttestations;\n\n    string constant PCK_PLATFORM_CA_COMMON_NAME = \"Intel SGX PCK Platform CA\";\n    string constant PCK_PROCESSOR_CA_COMMON_NAME = \"Intel SGX PCK Processor CA\";\n    string constant SIGNING_COMMON_NAME = \"Intel SGX TCB Signing\";\n    string constant ROOT_CA_COMMON_NAME = \"Intel SGX Root CA\";\n\n    // keccak256(hex\"0ba9c4c0c0c86193a3fe23d6b02cda10a8bbd4e88e48b4458561a36e705525f567918e2edc88e40d860bd0cc4ee26aacc988e505a953558c453f6b0904ae7394\")\n    // the uncompressed (0x04) prefix is not included in the pubkey pre-image\n    bytes32 constant ROOT_CA_PUBKEY_HASH = 0x89f72d7c488e5b53a77c23ebcb36970ef7eb5bcf6658e9b8292cfbe4703a8473;\n\n    error Missing_Certificate(CA ca);\n    error Invalid_PCK_CA(CA ca);\n    error Invalid_Issuer_Name();\n    error Invalid_Subject_Name();\n    error Certificate_Expired();\n    error Root_Key_Mismatch();\n    error Certificate_Revoked(CA ca, uint256 serialNum);\n    error Missing_Issuer();\n    error Invalid_Signature();\n\n    constructor(address _x509, address _crl) SigVerifyBase(_x509) {\n        crlLib = X509CRLHelper(_crl);\n    }\n\n    modifier pckCACheck(CA ca) {\n        if (ca == CA.ROOT || ca == CA.SIGNING) {\n            revert Invalid_PCK_CA(ca);\n        }\n        _;\n    }\n\n    /**\n     * @param ca see {Common.sol} for definition\n     * @return cert - DER encoded certificate\n     * @return crl - DER-encoded CRLs that is signed by the provided cert\n     */\n    function getCertificateById(CA ca) external view returns (bytes memory cert, bytes memory crl) {\n        bytes32 pcsCertAttestationId = pcsCertAttestations[ca];\n        if (pcsCertAttestationId == bytes32(0)) {\n            revert Missing_Certificate(ca);\n        }\n        cert = getAttestedData(pcsCertAttestationId);\n\n        bytes32 pcsCrlAttestationId = pcsCrlAttestations[ca];\n        if (pcsCrlAttestationId != bytes32(0)) {\n            crl = getAttestedData(pcsCrlAttestationId);\n        }\n    }\n\n    /**\n     * Section 4.2.6 (upsertPcsCertificates)\n     * @param ca replaces the \"id\" value with the ca_id\n     * @param cert the DER-encoded certificate\n     */\n    function upsertPcsCertificates(CA ca, bytes calldata cert) external returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCert(ca, cert);\n        AttestationRequest memory req = _buildPcsAttestationRequest(false, ca, cert);\n        attestationId = _attestPcs(req, hash);\n        pcsCertAttestations[ca] = attestationId;\n    }\n\n    /**\n     * Section 4.2.5 (upsertPckCrl)\n     * @param ca either CA.PROCESSOR or CA.PLATFORM\n     * @param crl the DER-encoded CRL\n     */\n    function upsertPckCrl(CA ca, bytes calldata crl) external pckCACheck(ca) returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(ca, crl);\n    }\n\n    function upsertRootCACrl(bytes calldata rootcacrl) external returns (bytes32 attestationId) {\n        attestationId = _upsertPcsCrl(CA.ROOT, rootcacrl);\n    }\n\n    function pcsCertSchemaID() public view virtual returns (bytes32 PCS_CERT_SCHEMA_ID);\n\n    function pcsCrlSchemaID() public view virtual returns (bytes32 PCS_CRL_SCHEMA_ID);\n\n    /**\n     * @dev implement logic to validate and attest PCS Certificates or CRLs\n     * @param req structure as defined by EAS\n     * https://github.com/ethereum-attestation-service/eas-contracts/blob/52af661748bde9b40ae782907702f885852bc149/contracts/IEAS.sol#L9C1-L23C2\n     * @return attestationId\n     */\n    function _attestPcs(AttestationRequest memory req, bytes32 hash) internal virtual returns (bytes32 attestationId);\n\n    function _upsertPcsCrl(CA ca, bytes calldata crl) private returns (bytes32 attestationId) {\n        bytes32 hash = _validatePcsCrl(ca, crl);\n        AttestationRequest memory req = _buildPcsAttestationRequest(true, ca, crl);\n        attestationId = _attestPcs(req, hash);\n        pcsCrlAttestations[ca] = attestationId;\n    }\n\n    /**\n     * @notice builds an EAS compliant attestation request\n     * @param isCrl - true only if the attested data is a CRL\n     * @param der - contains the DER encoded data, specified by isCrl and CA\n     */\n    function _buildPcsAttestationRequest(bool isCrl, CA ca, bytes calldata der)\n        private\n        view\n        returns (AttestationRequest memory req)\n    {\n        bytes32 predecessorAttestationId = isCrl ? pcsCrlAttestations[ca] : pcsCertAttestations[ca];\n        AttestationRequestData memory reqData = AttestationRequestData({\n            recipient: msg.sender,\n            expirationTime: 0, // assign zero here because this has already been checked\n            revocable: true,\n            refUID: predecessorAttestationId,\n            data: der,\n            value: 0\n        });\n        bytes32 schemaId = isCrl ? pcsCrlSchemaID() : pcsCertSchemaID();\n        req = AttestationRequest({schema: schemaId, data: reqData});\n    }\n\n    function _validatePcsCert(CA ca, bytes calldata cert) private view returns (bytes32 hash) {\n        X509Helper x509Lib = X509Helper(x509);\n\n        // Step 1: Check whether cert has expired\n        bool notExpired = x509Lib.certIsNotExpired(cert);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check issuer and subject common names are valid\n        string memory issuerName = x509Lib.getIssuerCommonName(cert);\n        string memory subjectName = x509Lib.getSubjectCommonName(cert);\n        string memory expectedIssuer = ROOT_CA_COMMON_NAME;\n        string memory expectedSubject;\n        if (ca == CA.PLATFORM) {\n            expectedSubject = PCK_PLATFORM_CA_COMMON_NAME;\n        } else if (ca == CA.PROCESSOR) {\n            expectedSubject = PCK_PROCESSOR_CA_COMMON_NAME;\n        } else if (ca == CA.SIGNING) {\n            expectedSubject = SIGNING_COMMON_NAME;\n        } else if (ca == CA.ROOT) {\n            expectedSubject = ROOT_CA_COMMON_NAME;\n        }\n\n        if (!LibString.eq(issuerName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n        if (!LibString.eq(subjectName, expectedSubject)) {\n            revert Invalid_Subject_Name();\n        }\n\n        // Step 3: Check Revocation Status\n        bytes memory rootCrlData = getAttestedData(pcsCrlAttestations[CA.ROOT]);\n        if (ca == CA.ROOT) {\n            bytes memory pubKey = x509Lib.getSubjectPublicKey(cert);\n            if (keccak256(pubKey) != ROOT_CA_PUBKEY_HASH) {\n                revert Root_Key_Mismatch();\n            }\n        } else if (rootCrlData.length > 0) {\n            uint256 serialNum = x509Lib.getSerialNumber(cert);\n            bool revoked = crlLib.serialNumberIsRevoked(serialNum, rootCrlData);\n            if (revoked) {\n                revert Certificate_Revoked(ca, serialNum);\n            }\n        }\n\n        // Step 4: Check signature\n        bytes memory rootCert = _getIssuer(CA.ROOT);\n        (bytes memory tbs, bytes memory signature) = x509Lib.getTbsAndSig(cert);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified;\n        if (ca == CA.ROOT) {\n            // the root certificate is issued by its own key\n            sigVerified = verifySignature(digest, signature, cert);\n        } else if (rootCert.length > 0) {\n            sigVerified = verifySignature(digest, signature, rootCert);\n        } else {\n            // all other certificates should already have an iusuer configured\n            revert Missing_Issuer();\n        }\n\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _validatePcsCrl(CA ca, bytes calldata crl) private view returns (bytes32 hash) {\n        // Step 1: Check whether CRL has expired\n        bool notExpired = crlLib.crlIsNotExpired(crl);\n        if (!notExpired) {\n            revert Certificate_Expired();\n        }\n\n        // Step 2: Check CRL issuer\n        string memory issuerCommonName = crlLib.getIssuerCommonName(crl);\n        string memory expectedIssuer;\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            expectedIssuer = ca == CA.PLATFORM ? PCK_PLATFORM_CA_COMMON_NAME : PCK_PROCESSOR_CA_COMMON_NAME;\n        } else {\n            expectedIssuer = ROOT_CA_COMMON_NAME;\n        }\n        if (!LibString.eq(issuerCommonName, expectedIssuer)) {\n            revert Invalid_Issuer_Name();\n        }\n\n        // Step 3: Verify signature\n        (bytes memory tbs, bytes memory signature) = crlLib.getTbsAndSig(crl);\n        bytes32 digest = sha256(tbs);\n        bool sigVerified = verifySignature(digest, signature, _getIssuer(ca));\n        if (!sigVerified) {\n            revert Invalid_Signature();\n        }\n\n        hash = keccak256(tbs);\n    }\n\n    function _getIssuer(CA ca) private view returns (bytes memory issuerCert) {\n        bytes32 intermediateCertAttestationId = pcsCertAttestations[ca];\n        bytes32 rootCertAttestationId = pcsCertAttestations[CA.ROOT];\n        if (ca == CA.PLATFORM || ca == CA.PROCESSOR) {\n            // this is applicable to crls only\n            // since all certs in the pcsdao are issued by the root\n            issuerCert = getAttestedData(intermediateCertAttestationId);\n        } else {\n            issuerCert = getAttestedData(rootCertAttestationId);\n        }\n    }\n}\n"},"src/bases/SigVerifyBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {P256Verifier} from \"../utils/P256Verifier.sol\";\n\ninterface IX509 {\n    function getSubjectPublicKey(bytes memory der) external pure returns (bytes memory pubKey);\n}\n\nabstract contract SigVerifyBase {\n    address public x509;\n\n    using BytesUtils for bytes;\n\n    constructor(address _x509helper) {\n        x509 = _x509helper;\n    }\n\n    function verifySignature(bytes32 digest, bytes memory signature, bytes memory signingCertBlob)\n        internal\n        view\n        returns (bool verified)\n    {\n        if (signature.length != 64) {\n            return false;\n        }\n\n        bytes memory pubKey = IX509(x509).getSubjectPublicKey(signingCertBlob);\n        if (pubKey.length != 64) {\n            return false;\n        }\n\n        verified = P256Verifier.ecdsaVerify(digest, signature, pubKey);\n    }\n}\n"},"src/helpers/FmspcTcbHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JSONParserLib} from \"solady/utils/JSONParserLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n// https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\nuint256 constant TCB_CPUSVN_SIZE = 16;\n\nenum TcbId {\n    /// the \"id\" field is absent from TCBInfo V2\n    /// which defaults TcbId to SGX\n    /// since TDX TCBInfos are only included in V3 or above\n    SGX,\n    TDX\n}\n\n/**\n * @title Solidity Object representing the TCBInfo JSON\n * @param tcbInfo: tcbInfoJson.tcbInfo string object body\n * @param signature The signature to be passed as bytes array\n */\nstruct TcbInfoJsonObj {\n    string tcbInfoStr;\n    bytes signature;\n}\n\nstruct TcbInfoBasic {\n    /// the name \"tcbType\" can be confusing/misleading\n    /// as the tcbType referred here in this struct is the type\n    /// of TCB level composition that determines TCB level comparison logic\n    /// It is not the same as the \"type\" parameter passed as an argument to the\n    /// getTcbInfo() API method described in Section 4.2.3 of the Intel PCCS Design Document\n    /// Instead, getTcbInfo() \"type\" argument should be checked against the \"id\" value of this struct\n    /// which represents the TEE type for the given TCBInfo\n    uint8 tcbType;\n    TcbId id;\n    uint32 version;\n    uint64 issueDate;\n    uint64 nextUpdate;\n    uint32 evaluationDataNumber;\n    bytes6 fmspc;\n    bytes2 pceid;\n}\n\nstruct TCBLevelsObj {\n    uint16 pcesvn;\n    uint8[] sgxComponentCpuSvns;\n    uint8[] tdxSvns;\n    uint64 tcbDateTimestamp;\n    TCBStatus status;\n}\n\nstruct TDXModule {\n    bytes mrsigner; // 48 bytes\n    bytes8 attributes;\n    bytes8 attributesMask;\n}\n\nstruct TDXModuleIdentity {\n    string id;\n    bytes8 attributes;\n    bytes8 attributesMask;\n    bytes mrsigner; // 48 bytes\n    TDXModuleTCBLevelsObj[] tcbLevels;\n}\n\nstruct TDXModuleTCBLevelsObj {\n    uint8 isvsvn;\n    uint64 tcbDateTimestamp;\n    TCBStatus status;\n}\n\nenum TCBStatus {\n    OK,\n    TCB_SW_HARDENING_NEEDED,\n    TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED,\n    TCB_CONFIGURATION_NEEDED,\n    TCB_OUT_OF_DATE,\n    TCB_OUT_OF_DATE_CONFIGURATION_NEEDED,\n    TCB_REVOKED,\n    TCB_UNRECOGNIZED\n}\n\n/**\n * @title FMSPC TCB Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse TCBInfo data\n * @notice The TCBInfo Object itself may vary by their version and type.\n * @notice This contract only provides a simple parser that could only extract basic info about the TCBInfo\n * such as, its version, type, fmspc, issue date and next update.\n * @dev should consider extending this contract to implement parsers that could extract detailed TCBInfo\n * using logic that complies to the specific version and type.\n */\ncontract FmspcTcbHelper {\n    using JSONParserLib for JSONParserLib.Item;\n    using LibString for string;\n\n    error TCBInfo_Invalid();\n    error TCB_TDX_Version_Invalid();\n    error TCB_TDX_ID_Invalid();\n\n    // 544k gas\n    function parseTcbString(string calldata tcbInfoStr) external pure returns (TcbInfoBasic memory tcbInfo) {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool tcbTypeFound;\n        bool fmspcFound;\n        bool versionFound;\n        bool issueDateFound;\n        bool nextUpdateFound;\n        bool pceidFound;\n        bool evaluationFound;\n        bool idFound;\n        bool allFound;\n\n        for (uint256 y = 0; y < root.size(); y++) {\n            JSONParserLib.Item memory current = tcbInfoObj[y];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            string memory val = current.value();\n            if (decodedKey.eq(\"tcbType\")) {\n                tcbInfo.tcbType = uint8(JSONParserLib.parseUint(val));\n                tcbTypeFound = true;\n            } else if (decodedKey.eq(\"id\")) {\n                string memory idStr = JSONParserLib.decodeString(val);\n                if (idStr.eq(\"SGX\")) {\n                    tcbInfo.id = TcbId.SGX;\n                } else if (idStr.eq(\"TDX\")) {\n                    tcbInfo.id = TcbId.TDX;\n                } else {\n                    revert TCBInfo_Invalid();\n                }\n                idFound = true;\n            } else if (decodedKey.eq(\"fmspc\")) {\n                tcbInfo.fmspc = bytes6(uint48(JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(val))));\n                fmspcFound = true;\n            } else if (decodedKey.eq(\"version\")) {\n                tcbInfo.version = uint32(JSONParserLib.parseUint(val));\n                versionFound = true;\n            } else if (decodedKey.eq(\"issueDate\")) {\n                tcbInfo.issueDate = uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(val)));\n                issueDateFound = true;\n            } else if (decodedKey.eq(\"nextUpdate\")) {\n                tcbInfo.nextUpdate = uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(val)));\n                nextUpdateFound = true;\n            } else if (decodedKey.eq(\"pceId\")) {\n                tcbInfo.pceid = bytes2(uint16(JSONParserLib.parseUintFromHex(JSONParserLib.decodeString(val))));\n                pceidFound = true;\n            } else if (decodedKey.eq(\"tcbEvaluationDataNumber\")) {\n                tcbInfo.evaluationDataNumber = uint32(JSONParserLib.parseUint(val));\n                evaluationFound = true;\n            }\n            if (versionFound) {\n                allFound =\n                    (tcbTypeFound && fmspcFound && issueDateFound && nextUpdateFound && pceidFound && evaluationFound);\n                if (tcbInfo.version >= 3) {\n                    allFound = allFound && idFound;\n                }\n                if (allFound) {\n                    break;\n                }\n            }\n        }\n\n        if (!allFound) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    // 1.4M gas\n    function parseTcbLevels(string calldata tcbInfoStr)\n        external\n        pure\n        returns (uint256 version, TCBLevelsObj[] memory tcbLevels)\n    {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool versionFound;\n        bool tcbLevelsFound;\n        JSONParserLib.Item[] memory tcbLevelsObj;\n\n        for (uint256 i = 0; i < root.size(); i++) {\n            JSONParserLib.Item memory current = tcbInfoObj[i];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            if (decodedKey.eq(\"version\")) {\n                version = JSONParserLib.parseUint(current.value());\n                versionFound = true;\n            }\n            if (decodedKey.eq(\"tcbLevels\")) {\n                tcbLevelsObj = current.children();\n                tcbLevelsFound = true;\n            }\n            if (versionFound && tcbLevelsFound) {\n                break;\n            }\n        }\n\n        if (versionFound && tcbLevelsFound) {\n            tcbLevels = _parseTCBLevels(version, tcbLevelsObj);\n        } else {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    // 684k gas\n    function parseTcbTdxModules(string calldata tcbInfoStr)\n        external\n        pure\n        returns (TDXModule memory module, TDXModuleIdentity[] memory moduleIdentities)\n    {\n        JSONParserLib.Item memory root = JSONParserLib.parse(tcbInfoStr);\n        JSONParserLib.Item[] memory tcbInfoObj = root.children();\n\n        bool versionFound;\n        bool idFound;\n        bool tdxModuleFound;\n        bool tdxModuleIdentitiesFound;\n        bool allFound;\n\n        for (uint256 i = 0; i < root.size(); i++) {\n            JSONParserLib.Item memory current = tcbInfoObj[i];\n            string memory decodedKey = JSONParserLib.decodeString(current.key());\n            if (decodedKey.eq(\"version\")) {\n                uint256 version = JSONParserLib.parseUint(current.value());\n                if (version < 3) {\n                    revert TCB_TDX_Version_Invalid();\n                }\n                versionFound = true;\n            }\n            if (decodedKey.eq(\"id\")) {\n                string memory id = JSONParserLib.decodeString(current.value());\n                if (!id.eq(\"TDX\")) {\n                    revert TCB_TDX_ID_Invalid();\n                }\n                idFound = true;\n            }\n            if (decodedKey.eq(\"tdxModule\")) {\n                module = _parseTdxModule(current.children());\n                tdxModuleFound = true;\n            }\n            if (decodedKey.eq(\"tdxModuleIdentities\")) {\n                moduleIdentities = _parseTdxModuleIdentities(current.children());\n                tdxModuleIdentitiesFound = true;\n            }\n            allFound = versionFound && idFound && tdxModuleFound && tdxModuleIdentitiesFound;\n            if (allFound) {\n                break;\n            }\n        }\n\n        if (!allFound) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    /// ====== INTERNAL METHODS BELOW ======\n\n    function _parseTCBLevels(uint256 version, JSONParserLib.Item[] memory tcbLevelsObj)\n        private\n        pure\n        returns (TCBLevelsObj[] memory tcbLevels)\n    {\n        uint256 tcbLevelsSize = tcbLevelsObj.length;\n        tcbLevels = new TCBLevelsObj[](tcbLevelsSize);\n\n        // iterating through the array\n        for (uint256 i = 0; i < tcbLevelsSize; i++) {\n            JSONParserLib.Item[] memory tcbObj = tcbLevelsObj[i].children();\n            // iterating through individual tcb objects\n            for (uint256 j = 0; j < tcbLevelsObj[i].size(); j++) {\n                string memory tcbKey = JSONParserLib.decodeString(tcbObj[j].key());\n                if (tcbKey.eq(\"tcb\")) {\n                    string memory tcbStr = tcbObj[j].value();\n                    JSONParserLib.Item memory tcbParent = JSONParserLib.parse(tcbStr);\n                    JSONParserLib.Item[] memory tcbComponents = tcbParent.children();\n                    if (version == 2) {\n                        (tcbLevels[i].sgxComponentCpuSvns, tcbLevels[i].pcesvn) = _parseV2Tcb(tcbComponents);\n                    } else if (version == 3) {\n                        (tcbLevels[i].sgxComponentCpuSvns, tcbLevels[i].tdxSvns, tcbLevels[i].pcesvn) =\n                            _parseV3Tcb(tcbComponents);\n                    } else {\n                        revert TCBInfo_Invalid();\n                    }\n                } else if (tcbKey.eq(\"tcbDate\")) {\n                    tcbLevels[i].tcbDateTimestamp =\n                        uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(tcbObj[j].value())));\n                } else if (tcbKey.eq(\"tcbStatus\")) {\n                    tcbLevels[i].status = _getTcbStatus(JSONParserLib.decodeString(tcbObj[j].value()));\n                }\n            }\n        }\n    }\n\n    function _getTcbStatus(string memory statusStr) private pure returns (TCBStatus status) {\n        if (statusStr.eq(\"UpToDate\")) {\n            status = TCBStatus.OK;\n        } else if (statusStr.eq(\"OutOfDate\")) {\n            status = TCBStatus.TCB_OUT_OF_DATE;\n        } else if (statusStr.eq(\"OutOfDateConfigurationNeeded\")) {\n            status = TCBStatus.TCB_OUT_OF_DATE_CONFIGURATION_NEEDED;\n        } else if (statusStr.eq(\"ConfigurationNeeded\")) {\n            status = TCBStatus.TCB_CONFIGURATION_NEEDED;\n        } else if (statusStr.eq(\"ConfigurationAndSWHardeningNeeded\")) {\n            status = TCBStatus.TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED;\n        } else if (statusStr.eq(\"SWHardeningNeeded\")) {\n            status = TCBStatus.TCB_SW_HARDENING_NEEDED;\n        } else if (statusStr.eq(\"Revoked\")) {\n            status = TCBStatus.TCB_REVOKED;\n        } else {\n            status = TCBStatus.TCB_UNRECOGNIZED;\n        }\n    }\n\n    function _parseV2Tcb(JSONParserLib.Item[] memory tcbComponents)\n        private\n        pure\n        returns (uint8[] memory sgxComponentCpuSvns, uint16 pcesvn)\n    {\n        sgxComponentCpuSvns = new uint8[](TCB_CPUSVN_SIZE);\n        uint256 cpusvnCounter = 0;\n        for (uint256 i = 0; i < tcbComponents.length; i++) {\n            string memory key = JSONParserLib.decodeString(tcbComponents[i].key());\n            uint256 value = JSONParserLib.parseUint(tcbComponents[i].value());\n            if (key.eq(\"pcesvn\")) {\n                pcesvn = uint16(value);\n            } else {\n                sgxComponentCpuSvns[cpusvnCounter++] = uint8(value);\n            }\n        }\n        if (cpusvnCounter != TCB_CPUSVN_SIZE) {\n            revert TCBInfo_Invalid();\n        }\n    }\n\n    function _parseV3Tcb(JSONParserLib.Item[] memory tcbComponents)\n        private\n        pure\n        returns (uint8[] memory sgxComponentCpuSvns, uint8[] memory tdxSvns, uint16 pcesvn)\n    {\n        sgxComponentCpuSvns = new uint8[](TCB_CPUSVN_SIZE);\n        tdxSvns = new uint8[](TCB_CPUSVN_SIZE);\n        for (uint256 i = 0; i < tcbComponents.length; i++) {\n            string memory key = JSONParserLib.decodeString(tcbComponents[i].key());\n            if (key.eq(\"pcesvn\")) {\n                pcesvn = uint16(JSONParserLib.parseUint(tcbComponents[i].value()));\n            } else {\n                string memory componentKey = key;\n                JSONParserLib.Item[] memory componentArr = tcbComponents[i].children();\n                uint256 cpusvnCounter = 0;\n                for (uint256 j = 0; j < tcbComponents[i].size(); j++) {\n                    JSONParserLib.Item[] memory component = componentArr[j].children();\n                    for (uint256 k = 0; k < componentArr[j].size(); k++) {\n                        key = JSONParserLib.decodeString(component[k].key());\n                        if (key.eq(\"svn\")) {\n                            if (componentKey.eq(\"tdxtcbcomponents\")) {\n                                tdxSvns[cpusvnCounter++] = uint8(JSONParserLib.parseUint(component[k].value()));\n                            } else {\n                                sgxComponentCpuSvns[cpusvnCounter++] =\n                                    uint8(JSONParserLib.parseUint(component[k].value()));\n                            }\n                        }\n                    }\n                }\n                if (cpusvnCounter != TCB_CPUSVN_SIZE) {\n                    revert TCBInfo_Invalid();\n                }\n            }\n        }\n    }\n\n    function _parseTdxModule(JSONParserLib.Item[] memory tdxModuleObj) private pure returns (TDXModule memory module) {\n        for (uint256 i = 0; i < tdxModuleObj.length; i++) {\n            string memory key = JSONParserLib.decodeString(tdxModuleObj[i].key());\n            string memory val = JSONParserLib.decodeString(tdxModuleObj[i].value());\n            if (key.eq(\"attributes\")) {\n                module.attributes = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n            }\n            if (key.eq(\"attributesMask\")) {\n                module.attributesMask = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n            }\n            if (key.eq(\"mrsigner\")) {\n                module.mrsigner = _getMrSignerHex(val);\n            }\n        }\n    }\n\n    function _parseTdxModuleIdentities(JSONParserLib.Item[] memory tdxModuleIdentitiesArr)\n        private\n        pure\n        returns (TDXModuleIdentity[] memory identities)\n    {\n        uint256 n = tdxModuleIdentitiesArr.length;\n        identities = new TDXModuleIdentity[](n);\n        for (uint256 i = 0; i < n; i++) {\n            JSONParserLib.Item[] memory currIdentity = tdxModuleIdentitiesArr[i].children();\n            for (uint256 j = 0; j < tdxModuleIdentitiesArr[i].size(); j++) {\n                string memory key = JSONParserLib.decodeString(currIdentity[j].key());\n                if (key.eq(\"id\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].id = val;\n                }\n                if (key.eq(\"mrsigner\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].mrsigner = _getMrSignerHex(val);\n                }\n                if (key.eq(\"attributes\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].attributes = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n                }\n                if (key.eq(\"attributesMask\")) {\n                    string memory val = JSONParserLib.decodeString(currIdentity[j].value());\n                    identities[i].attributesMask = bytes8(uint64(JSONParserLib.parseUintFromHex(val)));\n                }\n                if (key.eq(\"tcbLevels\")) {\n                    JSONParserLib.Item[] memory tcbLevelsArr = currIdentity[j].children();\n                    uint256 x = tcbLevelsArr.length;\n                    identities[i].tcbLevels = new TDXModuleTCBLevelsObj[](x);\n                    for (uint256 k = 0; k < x; k++) {\n                        JSONParserLib.Item[] memory tcb = tcbLevelsArr[k].children();\n                        for (uint256 l = 0; l < tcb.length; l++) {\n                            key = JSONParserLib.decodeString(tcb[l].key());\n                            if (key.eq(\"tcb\")) {\n                                JSONParserLib.Item[] memory isvsvnObj = tcb[l].children();\n                                key = JSONParserLib.decodeString(isvsvnObj[0].key());\n                                if (key.eq(\"isvsvn\")) {\n                                    identities[i].tcbLevels[k].isvsvn =\n                                        uint8(JSONParserLib.parseUint(isvsvnObj[0].value()));\n                                } else {\n                                    revert TCBInfo_Invalid();\n                                }\n                            }\n                            if (key.eq(\"tcbDate\")) {\n                                identities[i].tcbLevels[k].tcbDateTimestamp =\n                                    uint64(DateTimeUtils.fromISOToTimestamp(JSONParserLib.decodeString(tcb[l].value())));\n                            }\n                            if (key.eq(\"tcbStatus\")) {\n                                identities[i].tcbLevels[k].status =\n                                    _getTcbStatus(JSONParserLib.decodeString(tcb[l].value()));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function _getMrSignerHex(string memory mrSignerStr) private pure returns (bytes memory mrSignerBytes) {\n        string memory mrSignerUpper16BytesStr = mrSignerStr.slice(0, 16);\n        string memory mrSignerLower32BytesStr = mrSignerStr.slice(16, 48);\n        uint256 mrSignerUpperBytes = JSONParserLib.parseUintFromHex(mrSignerUpper16BytesStr);\n        uint256 mrSignerLowerBytes = JSONParserLib.parseUintFromHex(mrSignerLower32BytesStr);\n        mrSignerBytes = abi.encodePacked(uint128(mrSignerUpperBytes), mrSignerLowerBytes);\n    }\n}\n"},"src/helpers/X509Helper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 Certificates\n * @notice This is a simplified structure of a DER-decoded X509 Certificate\n */\nstruct X509CertObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    string subjectCommonName;\n    bytes subjectPublicKey;\n    // the extension needs to be parsed further for PCK Certificates\n    uint256 extensionPtr;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 Certificates Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded X509 certificates.\n * @dev The Extension sequence in Intel PCK Certificates is a custom ASN.1 Sequence that needs to be\n * @dev parsed further in a more specialized PCKHelper contract.\n */\ncontract X509Helper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CERTIFICATE\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function certIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function getSubjectCommonName(bytes calldata der) external pure returns (string memory subjectCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function getSubjectPublicKey(bytes calldata der) external pure returns (bytes memory pubKey) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        pubKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n    }\n\n    /// x509 Certificates generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. version\n    /// - 1b. serial number\n    /// - 1c. siganture algorithm\n    /// - 1d. issuer\n    /// - - 1d(a). common name\n    /// - - 1d(b). organization name\n    /// - - 1d(c). locality name\n    /// - - 1d(d). state or province name\n    /// - - 1d(e). country name\n    /// - 1e. validity\n    /// - - 1e(a) notBefore\n    /// - - 1e(b) notAfter\n    /// - 1f. subject\n    /// - - contains the same set of elements as 1d\n    /// - 1g. subject public key info\n    /// - - 1g(a). algorithm\n    /// - - 1g(b). subject public key\n    /// - 1h. Extensions\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    /// - 3a. X value\n    /// - 3b. Y value\n    function parseX509DER(bytes calldata der) external pure returns (X509CertObj memory cert) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        cert.tbs = der.allBytesAt(tbsParentPtr);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.serialNumber = _parseSerialNumber(der.bytesAt(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (cert.validityNotBefore, cert.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        cert.subjectCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        cert.subjectPublicKey = _getSubjectPublicKey(der, der.firstChildOf(tbsPtr));\n\n        cert.extensionPtr = der.nextSiblingOf(tbsPtr);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        cert.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = der.firstChildOf(validityPtr);\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getSubjectPublicKey(bytes calldata der, uint256 subjectPublicKeyInfoPtr)\n        private\n        pure\n        returns (bytes memory pubKey)\n    {\n        subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);\n        pubKey = der.bitstringAt(subjectPublicKeyInfoPtr);\n        if (pubKey.length != 65) {\n            // TODO: we need to figure out how to handle key with prefix byte 0x02 or 0x03\n            revert(\"compressed public key not supported\");\n        }\n        pubKey = _trimBytes(pubKey, 64);\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(sigX, sigY);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"},"src/helpers/X509CRLHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Asn1Decode, NodePtr} from \"../utils/Asn1Decode.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {DateTimeUtils} from \"../utils/DateTimeUtils.sol\";\n\n/**\n * @title Solidity Structure representing X509 CRL\n * @notice This is a simplified structure of a DER-decoded X509 CRL\n */\nstruct X509CRLObj {\n    uint256 serialNumber;\n    string issuerCommonName;\n    uint256 validityNotBefore;\n    uint256 validityNotAfter;\n    uint256[] serialNumbersRevoked;\n    // for signature verification in the cert chain\n    bytes signature;\n    bytes tbs;\n}\n\n/**\n * @title X509 CRL Helper Contract\n * @notice This is a standalone contract that can be used by off-chain applications and smart contracts\n * to parse DER-encoded CRLs.\n */\ncontract X509CRLHelper {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    // 2.5.29.20\n    bytes constant CRL_NUMBER_OID = hex\"551d14\";\n\n    /// =================================================================================\n    /// USE THE GETTERS BELOW IF YOU DON'T WANT TO PARSE THE ENTIRE X509 CRL\n    /// =================================================================================\n\n    function getTbsAndSig(bytes calldata der) external pure returns (bytes memory tbs, bytes memory sig) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n\n        tbs = der.allBytesAt(tbsParentPtr);\n        sig = _getSignature(der, sigPtr);\n    }\n\n    function getSerialNumber(bytes calldata der) external pure returns (uint256 serialNum) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        serialNum = _parseSerialNumber(der.bytesAt(tbsPtr));\n    }\n\n    function getIssuerCommonName(bytes calldata der) external pure returns (string memory issuerCommonName) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n    }\n\n    function crlIsNotExpired(bytes calldata der) external view returns (bool isValid) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (uint256 validityNotBefore, uint256 validityNotAfter) = _getValidity(der, tbsPtr);\n        isValid = block.timestamp > validityNotBefore && block.timestamp < validityNotAfter;\n    }\n\n    function serialNumberIsRevoked(uint256 serialNumber, bytes calldata der) external pure returns (bool revoked) {\n        uint256 root = der.root();\n        uint256 tbsParentPtr = der.firstChildOf(root);\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        uint256[] memory ret = _getRevokedSerialNumbers(der, tbsPtr, true, serialNumber);\n        revoked = ret[0] == serialNumber;\n    }\n\n    /// x509 CRL generally contain a sequence of elements in the following order:\n    /// 1. tbs\n    /// - 1a. serial number\n    /// - 1b. signature algorithm\n    /// - 1c. issuer\n    /// - - 1c(a). common name\n    /// - - 1c(b). organization name\n    /// - - 1c(c). locality name\n    /// - - 1c(d). state or province name\n    /// - - 1c(e). country name\n    /// - 1d. not before\n    /// - 1e. not after\n    /// - 1f. revoked certificates\n    /// - - A list consists of revoked serial numbers and reasons.\n    /// - 1g. CRL extensions\n    /// - - 1g(a) CRL number\n    /// - - 1g(b) Authority Key Identifier\n    /// 2. Signature Algorithm\n    /// 3. Signature\n    /// - 3a. X value\n    /// - 3b. Y value\n    function parseCRLDER(bytes calldata der) external pure returns (X509CRLObj memory crl) {\n        uint256 root = der.root();\n\n        uint256 tbsParentPtr = der.firstChildOf(root);\n\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        crl.serialNumber = uint256(bytes32(der.bytesAt(tbsPtr)));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.issuerCommonName = _getCommonName(der, der.firstChildOf(tbsPtr));\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        (crl.validityNotBefore, crl.validityNotAfter) = _getValidity(der, tbsPtr);\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        crl.serialNumbersRevoked = _getRevokedSerialNumbers(der, tbsPtr, false, 0);\n\n        // tbs iteration completed\n        // now we just need to look for the signature\n\n        uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n        sigPtr = der.nextSiblingOf(sigPtr);\n        crl.signature = _getSignature(der, sigPtr);\n    }\n\n    function _getCommonName(bytes calldata der, uint256 commonNameParentPtr)\n        private\n        pure\n        returns (string memory commonName)\n    {\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.firstChildOf(commonNameParentPtr);\n        commonNameParentPtr = der.nextSiblingOf(commonNameParentPtr);\n        commonName = string(der.bytesAt(commonNameParentPtr));\n    }\n\n    function _getValidity(bytes calldata der, uint256 validityPtr)\n        private\n        pure\n        returns (uint256 notBefore, uint256 notAfter)\n    {\n        uint256 notBeforePtr = validityPtr;\n        uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n        notBefore = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notBeforePtr));\n        notAfter = DateTimeUtils.fromDERToTimestamp(der.bytesAt(notAfterPtr));\n    }\n\n    function _getRevokedSerialNumbers(bytes calldata der, uint256 revokedParentPtr, bool breakIfFound, uint256 filter)\n        private\n        pure\n        returns (uint256[] memory serialNumbers)\n    {\n        uint256 revokedPtr = der.firstChildOf(revokedParentPtr);\n\n        if (der[revokedPtr.ixs()] == 0xA0) {\n            uint256 crlExtensionPtr = der.firstChildOf(revokedPtr);\n            require(BytesUtils.compareBytes(der.bytesAt(crlExtensionPtr), CRL_NUMBER_OID), \"invalid CRL\");\n        } else {\n            bytes memory serials;\n            while (revokedPtr.ixl() <= revokedParentPtr.ixl()) {\n                uint256 serialPtr = der.firstChildOf(revokedPtr);\n                bytes memory serialBytes = der.bytesAt(serialPtr);\n                uint256 serialNumber = _parseSerialNumber(serialBytes);\n                serials = abi.encodePacked(serials, serialNumber);\n                if (breakIfFound && filter == serialNumber) {\n                    serialNumbers = new uint256[](1);\n                    serialNumbers[0] = filter;\n                    return serialNumbers;\n                }\n                revokedPtr = der.nextSiblingOf(revokedPtr);\n            }\n            uint256 count = serials.length / 32;\n            // ABI encoding format for a dynamic uint256[] value\n            serials = abi.encodePacked(abi.encode(0x20), abi.encode(count), serials);\n            serialNumbers = new uint256[](count);\n            serialNumbers = abi.decode(serials, (uint256[]));\n        }\n    }\n\n    function _parseSerialNumber(bytes memory serialBytes) private pure returns (uint256 serial) {\n        uint256 shift = 8 * (32 - serialBytes.length);\n        serial = uint256(bytes32(serialBytes) >> shift);\n    }\n\n    function _getSignature(bytes calldata der, uint256 sigPtr) private pure returns (bytes memory sig) {\n        sigPtr = der.rootOfBitStringAt(sigPtr);\n\n        sigPtr = der.firstChildOf(sigPtr);\n        bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sigPtr = der.nextSiblingOf(sigPtr);\n        bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);\n\n        sig = abi.encodePacked(sigX, sigY);\n    }\n\n    /// @dev remove unnecessary prefix from the input\n    /// @dev remove unnecessary prefix from the input\n    function _trimBytes(bytes memory input, uint256 expectedLength) private pure returns (bytes memory output) {\n        uint256 n = input.length;\n        if (n == expectedLength) {\n            output = input;\n        } else if (n < expectedLength) {\n            output = new bytes(expectedLength);\n            uint256 padLength = expectedLength - n;\n            for (uint256 i = 0; i < n; i++) {\n                output[padLength + i] = input[i];\n            }\n        } else {\n            uint256 lengthDiff = n - expectedLength;\n            output = input.substring(lengthDiff, expectedLength);\n        }\n    }\n}\n"},"lib/solady/src/utils/LibString.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, s)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"},"src/utils/BytesUtils.sol":{"content":"// SPDX-License-Identifier: BSD 2-Clause License\npragma solidity ^0.8.0;\n\n// Inspired by ensdomains/dnssec-oracle - BSD-2-Clause license\n// https://github.com/ensdomains/dnssec-oracle/blob/master/contracts/BytesUtils.sol\n\nlibrary BytesUtils {\n    /*\n    * @dev Returns the keccak-256 hash of a byte range.\n    * @param self The byte string to hash.\n    * @param offset The position to start hashing at.\n    * @param len The number of bytes to hash.\n    * @return The hash of the byte range.\n    */\n    function keccak(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal.\n    * @param self The first bytes to compare.\n    * @param other The second bytes to compare.\n    * @return The result of the comparison.\n    */\n    function compare(bytes memory self, bytes memory other) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns a positive number if `other` comes lexicographically after\n    *      `self`, a negative number if it comes before, or zero if the\n    *      contents of the two bytes are equal. Comparison is done per-rune,\n    *      on unicode codepoints.\n    * @param self The first bytes to compare.\n    * @param offset The offset of self.\n    * @param len    The length of self.\n    * @param other The second bytes to compare.\n    * @param otheroffset The offset of the other string.\n    * @param otherlen    The length of the other string.\n    * @return The result of the comparison.\n    */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        uint256 shortest = len;\n        if (otherlen < len) {\n            shortest = otherlen;\n        }\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max; // aka 0xffffff....\n                } else {\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                }\n                uint256 diff = (a & mask) - (b & mask);\n                if (diff != 0) {\n                    return int256(diff);\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @param len The number of bytes to compare\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset, uint256 len)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal with offsets.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @param otherOffset The offset into the second byte range.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other, uint256 otherOffset)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\n    *      they are equal.\n    * @param self The first byte range to compare.\n    * @param offset The offset into the first byte range.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, uint256 offset, bytes memory other) internal pure returns (bool) {\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n    * @dev Returns true if the two byte ranges are equal.\n    * @param self The first byte range to compare.\n    * @param other The second byte range to compare.\n    * @return True if the byte ranges are equal, false otherwise.\n    */\n    function equals(bytes memory self, bytes memory other) internal pure returns (bool) {\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n    * @dev Returns the 8-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 8 bits of the string, interpreted as an integer.\n    */\n    function readUint8(bytes memory self, uint256 idx) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n    * @dev Returns the 16-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 16 bits of the string, interpreted as an integer.\n    */\n    function readUint16(bytes memory self, uint256 idx) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32-bit number at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bits of the string, interpreted as an integer.\n    */\n    function readUint32(bytes memory self, uint256 idx) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes32(bytes memory self, uint256 idx) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n    * @dev Returns the 32 byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytes20(bytes memory self, uint256 idx) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret :=\n                and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\n        }\n    }\n\n    /*\n    * @dev Returns the n byte value at the specified index of self.\n    * @param self The byte string.\n    * @param idx The index into the bytes.\n    * @param len The number of bytes.\n    * @return The specified 32 bytes of the string.\n    */\n    function readBytesN(bytes memory self, uint256 idx, uint256 len) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask;\n        if (len == 0) {\n            mask = type(uint256).max; // Set to maximum value of uint256\n        } else {\n            mask = 256 ** (32 - len) - 1;\n        }\n\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n    * @dev Copies a substring into a new byte string.\n    * @param self The byte string to copy from.\n    * @param offset The offset to start copying at.\n    * @param len The number of bytes to copy.\n    */\n    function substring(bytes memory self, uint256 offset, uint256 len) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(bytes memory self, uint256 off, uint256 len) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    function compareBytes(bytes memory a, bytes memory b) internal pure returns (bool) {\n        if (a.length != b.length) {\n            return false;\n        }\n        for (uint256 i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},"src/utils/P256Verifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./BytesUtils.sol\";\n\n/**\n * @notice modified from https://github.com/daimo-eth/p256-verifier/\n */\nlibrary P256Verifier {\n    using BytesUtils for bytes;\n\n    address internal constant P256_VERIFIER = 0xc2b78104907F722DABAc4C69f826a522B2754De4;\n\n    function ecdsaVerify(bytes32 messageHash, bytes memory signature, bytes memory key)\n        internal\n        view\n        returns (bool verified)\n    {\n        bytes memory args = abi.encode(\n            messageHash,\n            uint256(bytes32(signature.substring(0, 32))),\n            uint256(bytes32(signature.substring(32, 32))),\n            uint256(bytes32(key.substring(0, 32))),\n            uint256(bytes32(key.substring(32, 32)))\n        );\n        (bool success, bytes memory ret) = P256_VERIFIER.staticcall(args);\n        assert(success); // never reverts, always returns 0 or 1\n\n        verified = abi.decode(ret, (uint256)) == 1;\n    }\n}\n"},"lib/solady/src/utils/JSONParserLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for parsing JSONs.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/JSONParserLib.sol)\nlibrary JSONParserLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The input is invalid.\n    error ParsingFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // There are 6 types of variables in JSON (excluding undefined).\n\n    /// @dev For denoting that an item has not been initialized.\n    /// A item returned from `parse` will never be of an undefined type.\n    /// Parsing a invalid JSON string will simply revert.\n    uint8 internal constant TYPE_UNDEFINED = 0;\n\n    /// @dev Type representing an array (e.g. `[1,2,3]`).\n    uint8 internal constant TYPE_ARRAY = 1;\n\n    /// @dev Type representing an object (e.g. `{\"a\":\"A\",\"b\":\"B\"}`).\n    uint8 internal constant TYPE_OBJECT = 2;\n\n    /// @dev Type representing a number (e.g. `-1.23e+21`).\n    uint8 internal constant TYPE_NUMBER = 3;\n\n    /// @dev Type representing a string (e.g. `\"hello\"`).\n    uint8 internal constant TYPE_STRING = 4;\n\n    /// @dev Type representing a boolean (i.e. `true` or `false`).\n    uint8 internal constant TYPE_BOOLEAN = 5;\n\n    /// @dev Type representing null (i.e. `null`).\n    uint8 internal constant TYPE_NULL = 6;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A pointer to a parsed JSON node.\n    struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }\n\n    // Private constants for packing `_data`.\n\n    uint256 private constant _BITPOS_STRING = 32 * 7 - 8;\n    uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;\n    uint256 private constant _BITPOS_KEY = 32 * 5 - 8;\n    uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;\n    uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;\n    uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;\n    uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;\n    uint256 private constant _BITMASK_POINTER = 0xffffffff;\n    uint256 private constant _BITMASK_TYPE = 7;\n    uint256 private constant _KEY_INITED = 1 << 3;\n    uint256 private constant _VALUE_INITED = 1 << 4;\n    uint256 private constant _CHILDREN_INITED = 1 << 5;\n    uint256 private constant _PARENT_IS_ARRAY = 1 << 6;\n    uint256 private constant _PARENT_IS_OBJECT = 1 << 7;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   JSON PARSING OPERATION                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Parses the JSON string `s`, and returns the root.\n    /// Reverts if `s` is not a valid JSON as specified in RFC 8259.\n    /// Object items WILL simply contain all their children, inclusive of repeated keys,\n    /// in the same order which they appear in the JSON string.\n    ///\n    /// Note: For efficiency, this function WILL NOT make a copy of `s`.\n    /// The parsed tree WILL contain offsets to `s`.\n    /// Do NOT pass in a string that WILL be modified later on.\n    function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    JSON ITEM OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note:\n    // - An item is a node in the JSON tree.\n    // - The value of a string item WILL be double-quoted, JSON encoded.\n    // - We make a distinction between `index` and `key`.\n    //   - Items in arrays are located by `index` (uint256).\n    //   - Items in objects are located by `key` (string).\n    // - Keys are always strings, double-quoted, JSON encoded.\n    //\n    // These design choices are made to balance between efficiency and ease-of-use.\n\n    /// @dev Returns the string value of the item.\n    /// This is its exact string representation in the original JSON string.\n    /// The returned string WILL have leading and trailing whitespace trimmed.\n    /// All inner whitespace WILL be preserved, exactly as it is in the original JSON string.\n    /// If the item's type is string, the returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the index of the item in the array.\n    /// It the item's parent is not an array, returns 0.\n    function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item's parent is not an object, returns an empty string.\n    /// The returned string WILL be double-quoted, JSON encoded.\n    ///\n    /// Note: This function lazily instantiates and caches the returned string.\n    /// Do NOT modify the returned string.\n    function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }\n\n    /// @dev Returns the key of the item in the object.\n    /// It the item is neither an array nor object, returns an empty array.\n    ///\n    /// Note: This function lazily instantiates and caches the returned array.\n    /// Do NOT modify the returned array.\n    function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }\n\n    /// @dev Returns the number of children.\n    /// It the item is neither an array nor object, returns zero.\n    function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }\n\n    /// @dev Returns the item at index `i` for (array).\n    /// If `item` is not an array, the result's type WILL be undefined.\n    /// If there is no item with the index, the result's type WILL be undefined.\n    function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }\n\n    /// @dev Returns the item at key `k` for (object).\n    /// If `item` is not an object, the result's type WILL be undefined.\n    /// The key MUST be double-quoted, JSON encoded. This is for efficiency reasons.\n    /// - Correct : `item.at('\"k\"')`.\n    /// - Wrong   : `item.at(\"k\")`.\n    /// For duplicated keys, the last item with the key WILL be returned.\n    /// If there is no item with the key, the result's type WILL be undefined.\n    function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }\n\n    /// @dev Returns the item's type.\n    function getType(Item memory item) internal pure returns (uint8 result) {\n        result = uint8(item._data & _BITMASK_TYPE);\n    }\n\n    /// Note: All types are mutually exclusive.\n\n    /// @dev Returns whether the item is of type undefined.\n    function isUndefined(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_UNDEFINED;\n    }\n\n    /// @dev Returns whether the item is of type array.\n    function isArray(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_ARRAY;\n    }\n\n    /// @dev Returns whether the item is of type object.\n    function isObject(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_OBJECT;\n    }\n\n    /// @dev Returns whether the item is of type number.\n    function isNumber(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NUMBER;\n    }\n\n    /// @dev Returns whether the item is of type string.\n    function isString(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_STRING;\n    }\n\n    /// @dev Returns whether the item is of type boolean.\n    function isBoolean(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_BOOLEAN;\n    }\n\n    /// @dev Returns whether the item is of type null.\n    function isNull(Item memory item) internal pure returns (bool result) {\n        result = item._data & _BITMASK_TYPE == TYPE_NULL;\n    }\n\n    /// @dev Returns the item's parent.\n    /// If the item does not have a parent, the result's type will be undefined.\n    function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     UTILITY FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Parses an unsigned integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid uint256 string matching the RegEx `^[0-9]+$`,\n    /// or if the parsed number is too big for a uint256.\n    function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Parses a signed integer from a string (in decimal, i.e. base 10).\n    /// Reverts if `s` is not a valid int256 string matching the RegEx `^[+-]?[0-9]+$`,\n    /// or if the parsed number is too big for a int256.\n    function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(255, x) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }\n\n    /// @dev Parses an unsigned integer from a string (in hexadecimal, i.e. base 16).\n    /// Reverts if `s` is not a valid uint256 hex string matching the RegEx\n    /// `^(0[xX])?[0-9a-fA-F]+$`, or if the parsed number is too big for a uint256.\n    function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Decodes a JSON encoded string.\n    /// The string MUST be double-quoted, JSON encoded.\n    /// Reverts if the string is invalid.\n    /// As you can see, it's pretty complex for a deceptively simple looking task.\n    function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Performs a query on the input with the given mode.\n    function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n\n    /// @dev Casts the input to a bytes32.\n    function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }\n}\n"},"src/utils/DateTimeUtils.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport {DateTimeLib} from \"solady/utils/DateTimeLib.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\nlibrary DateTimeUtils {\n    using LibString for string;\n\n    /*\n     * @dev Convert a DER-encoded time to a unix timestamp\n     * @param x509Time The DER-encoded time\n     * @return The unix timestamp\n     */\n    function fromDERToTimestamp(bytes memory x509Time) internal pure returns (uint256) {\n        uint16 yrs;\n        uint8 mnths;\n        uint8 dys;\n        uint8 hrs;\n        uint8 mins;\n        uint8 secs;\n        uint8 offset;\n\n        if (x509Time.length == 13) {\n            if (uint8(x509Time[0]) - 48 < 5) yrs += 2000;\n            else yrs += 1900;\n        } else {\n            yrs += (uint8(x509Time[0]) - 48) * 1000 + (uint8(x509Time[1]) - 48) * 100;\n            offset = 2;\n        }\n        yrs += (uint8(x509Time[offset + 0]) - 48) * 10 + uint8(x509Time[offset + 1]) - 48;\n        mnths = (uint8(x509Time[offset + 2]) - 48) * 10 + uint8(x509Time[offset + 3]) - 48;\n        dys += (uint8(x509Time[offset + 4]) - 48) * 10 + uint8(x509Time[offset + 5]) - 48;\n        hrs += (uint8(x509Time[offset + 6]) - 48) * 10 + uint8(x509Time[offset + 7]) - 48;\n        mins += (uint8(x509Time[offset + 8]) - 48) * 10 + uint8(x509Time[offset + 9]) - 48;\n        secs += (uint8(x509Time[offset + 10]) - 48) * 10 + uint8(x509Time[offset + 11]) - 48;\n\n        return DateTimeLib.dateTimeToTimestamp(yrs, mnths, dys, hrs, mins, secs);\n    }\n\n    /// @dev iso follows pattern: \"YYYY-MM-DDTHH:mm:ssZ\"\n    function fromISOToTimestamp(string memory iso) internal pure returns (uint256) {\n        require(bytes(iso).length == 20, \"invalid iso string length\");\n        uint256 y = stringToUint(iso.slice(0, 4));\n        uint256 m = stringToUint(iso.slice(5, 7));\n        uint256 d = stringToUint(iso.slice(8, 10));\n        uint256 h = stringToUint(iso.slice(11, 13));\n        uint256 min = stringToUint(iso.slice(14, 16));\n        uint256 s = stringToUint(iso.slice(17, 19));\n\n        return DateTimeLib.dateTimeToTimestamp(y, m, d, h, min, s);\n    }\n\n    // https://ethereum.stackexchange.com/questions/10932/how-to-convert-string-to-int\n    function stringToUint(string memory s) private pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 c = uint256(uint8(b[i]));\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n}\n"},"src/utils/Asn1Decode.sol":{"content":"// SPDX-License-Identifier: MIT\n// Original source: https://github.com/JonahGroendal/asn1-decode\npragma solidity ^0.8.0;\n\n// Inspired by PufferFinance/rave - Apache-2.0 license\n// https://github.com/JonahGroendal/asn1-decode/blob/5c2d1469fc678513753786acb441e597969192ec/contracts/Asn1Decode.sol\n\nimport \"./BytesUtils.sol\";\n\nlibrary NodePtr {\n    // Unpack first byte index\n    function ixs(uint256 self) internal pure returns (uint256) {\n        return uint80(self);\n    }\n    // Unpack first content byte index\n\n    function ixf(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 80);\n    }\n    // Unpack last content byte index\n\n    function ixl(uint256 self) internal pure returns (uint256) {\n        return uint80(self >> 160);\n    }\n    // Pack 3 uint80s into a uint256\n\n    function getPtr(uint256 _ixs, uint256 _ixf, uint256 _ixl) internal pure returns (uint256) {\n        _ixs |= _ixf << 80;\n        _ixs |= _ixl << 160;\n        return _ixs;\n    }\n}\n\nlibrary Asn1Decode {\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    /*\n    * @dev Get the root node. First step in traversing an ASN1 structure\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function root(bytes memory der) internal pure returns (uint256) {\n        return readNodeLength(der, 0);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within a bit string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfBitStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        return readNodeLength(der, ptr.ixf() + 1);\n    }\n\n    /*\n    * @dev Get the root node of an ASN1 structure that's within an octet string value\n    * @param der The DER-encoded ASN1 structure\n    * @return A pointer to the outermost node\n    */\n    function rootOfOctetStringAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x04, \"Not type OCTET STRING\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Get the next sibling node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the next sibling node\n    */\n    function nextSiblingOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        return readNodeLength(der, ptr.ixl() + 1);\n    }\n\n    /*\n    * @dev Get the first child node of the current node\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return A pointer to the first child node\n    */\n    function firstChildOf(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] & 0x20 == 0x20, \"Not a constructed type\");\n        return readNodeLength(der, ptr.ixf());\n    }\n\n    /*\n    * @dev Use for looping through children of a node (either i or j).\n    * @param i Pointer to an ASN1 node\n    * @param j Pointer to another ASN1 node of the same ASN1 structure\n    * @return True iff j is child of i or i is child of j.\n    */\n    function isChildOf(uint256 i, uint256 j) internal pure returns (bool) {\n        return (((i.ixf() <= j.ixs()) && (j.ixl() <= i.ixl())) || ((j.ixf() <= i.ixs()) && (i.ixl() <= j.ixl())));\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node\n    */\n    function bytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract entire node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return All bytes of node\n    */\n    function allBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        return der.substring(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of node as bytes32\n    */\n    function bytes32At(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.readBytesN(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    /*\n    * @dev Extract value of node from DER-encoded structure\n    * @param der The der-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Uint value of node\n    */\n    function uintAt(bytes memory der, uint256 ptr) internal pure returns (uint256) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 len = ptr.ixl() + 1 - ptr.ixf();\n        return uint256(der.readBytesN(ptr.ixf(), len) >> (32 - len) * 8);\n    }\n\n    /*\n    * @dev Extract value of a positive integer node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value bytes of a positive integer node\n    */\n    function uintBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x02, \"Not type INTEGER\");\n        require(der[ptr.ixf()] & 0x80 == 0, \"Not positive\");\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        if (der[ptr.ixf()] == 0) {\n            return der.substring(ptr.ixf() + 1, valueLength - 1);\n        } else {\n            return der.substring(ptr.ixf(), valueLength);\n        }\n    }\n\n    function keccakOfBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixf(), ptr.ixl() + 1 - ptr.ixf());\n    }\n\n    function keccakOfAllBytesAt(bytes memory der, uint256 ptr) internal pure returns (bytes32) {\n        return der.keccak(ptr.ixs(), ptr.ixl() + 1 - ptr.ixs());\n    }\n\n    /*\n    * @dev Extract value of bitstring node from DER-encoded structure\n    * @param der The DER-encoded ASN1 structure\n    * @param ptr Points to the indices of the current node\n    * @return Value of bitstring converted to bytes\n    */\n    function bitstringAt(bytes memory der, uint256 ptr) internal pure returns (bytes memory) {\n        require(der[ptr.ixs()] == 0x03, \"Not type BIT STRING\");\n        // Only 00 padded bitstr can be converted to bytestr!\n        require(der[ptr.ixf()] == 0x00);\n        uint256 valueLength = ptr.ixl() + 1 - ptr.ixf();\n        return der.substring(ptr.ixf() + 1, valueLength - 1);\n    }\n\n    function readNodeLength(bytes memory der, uint256 ix) private pure returns (uint256) {\n        uint256 length;\n        uint80 ixFirstContentByte;\n        uint80 ixLastContentByte;\n        if ((der[ix + 1] & 0x80) == 0) {\n            length = uint8(der[ix + 1]);\n            ixFirstContentByte = uint80(ix + 2);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        } else {\n            uint8 lengthbytesLength = uint8(der[ix + 1] & 0x7F);\n            if (lengthbytesLength == 1) {\n                length = der.readUint8(ix + 2);\n            } else if (lengthbytesLength == 2) {\n                length = der.readUint16(ix + 2);\n            } else {\n                length = uint256(der.readBytesN(ix + 2, lengthbytesLength) >> (32 - lengthbytesLength) * 8);\n            }\n            ixFirstContentByte = uint80(ix + 2 + lengthbytesLength);\n            ixLastContentByte = uint80(ixFirstContentByte + length - 1);\n        }\n        return NodePtr.getPtr(ix, ixFirstContentByte, ixLastContentByte);\n    }\n}\n"},"lib/solady/src/utils/DateTimeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for date time operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\n///\n/// Conventions:\n/// --------------------------------------------------------------------+\n/// Unit      | Range                | Notes                            |\n/// --------------------------------------------------------------------|\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\n/// month     | 1..12                | Gregorian calendar month.        |\n/// day       | 1..31                | Gregorian calendar day of month. |\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\n/// --------------------------------------------------------------------+\n/// All timestamps of days are rounded down to 00:00:00 UTC.\nlibrary DateTimeLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Weekdays are 1-indexed for a traditional rustic feel.\n\n    // \"And on the seventh day God finished his work that he had done,\n    // and he rested on the seventh day from all his work that he had done.\"\n    // -- Genesis 2:2\n\n    uint256 internal constant MON = 1;\n    uint256 internal constant TUE = 2;\n    uint256 internal constant WED = 3;\n    uint256 internal constant THU = 4;\n    uint256 internal constant FRI = 5;\n    uint256 internal constant SAT = 6;\n    uint256 internal constant SUN = 7;\n\n    // Months and days of months are 1-indexed for ease of use.\n\n    uint256 internal constant JAN = 1;\n    uint256 internal constant FEB = 2;\n    uint256 internal constant MAR = 3;\n    uint256 internal constant APR = 4;\n    uint256 internal constant MAY = 5;\n    uint256 internal constant JUN = 6;\n    uint256 internal constant JUL = 7;\n    uint256 internal constant AUG = 8;\n    uint256 internal constant SEP = 9;\n    uint256 internal constant OCT = 10;\n    uint256 internal constant NOV = 11;\n    uint256 internal constant DEC = 12;\n\n    // These limits are large enough for most practical purposes.\n    // Inputs that exceed these limits result in undefined behavior.\n\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    DATE TIME OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\n    /// See: https://howardhinnant.github.io/date_algorithms.html\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDays} to check if the inputs is supported.\n    function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }\n\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDate} to check if the inputs are supported.\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }\n\n    /// @dev Returns the unix timestamp from\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\n    function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }\n\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\n    /// from the given unix timestamp.\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }\n\n    /// @dev Returns if the `year` is leap.\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }\n\n    /// @dev Returns number of days in given `month` of `year`.\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1F1C1F1E1F1E1F1F1E1F1E1F)), and(eq(month, 2), flag))\n        }\n    }\n\n    /// @dev Returns the weekday from the unix timestamp.\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0)\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(add(month, w), 12), lt(add(day, w), md))\n                )\n        }\n    }\n\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\n    /// - `1 <= month <= 12`.\n    /// - `1 <= day <= daysInMonth(year, month)`.\n    /// - `hour < 24`.\n    /// - `minute < 60`.\n    /// - `second < 60`.\n    function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }\n\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }\n\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\n    /// Note: `n` is 1-indexed for traditional consistency.\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }\n\n    /// @dev Returns the unix timestamp of the most recent Monday.\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }\n\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\n    /// To check whether it is a week day, just take the negation of the result.\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\n        result = weekday(timestamp) > FRI;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }\n\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }\n\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp + numDays * 86400;\n    }\n\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp + numHours * 3600;\n    }\n\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\n    function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }\n\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\n    function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: The result will share the same Gregorian calendar month,\n    /// but different Gregorian calendar years for non-zero `numYears`.\n    /// If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }\n\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\n    /// Note: If the Gregorian calendar month of the result has less days\n    /// than the Gregorian calendar month day of the `timestamp`,\n    /// the result's month day will be the maximum possible value for the month.\n    /// (e.g. from 29th Feb to 28th Feb)\n    function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }\n\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\n        result = timestamp - numDays * 86400;\n    }\n\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\n        result = timestamp - numHours * 3600;\n    }\n\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\n    function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }\n\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\n    function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }\n\n    /// @dev Returns the difference in Gregorian calendar years\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a year,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar years\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }\n\n    /// @dev Returns the difference in Gregorian calendar months\n    /// between `fromTimestamp` and `toTimestamp`.\n    /// Note: Even if the true time difference is less than a month,\n    /// the difference can be non-zero is the timestamps are\n    /// from different Gregorian calendar months.\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }\n\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }\n\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }\n\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }\n\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unchecked arithmetic for computing the total number of months.\n    function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for adding two numbers.\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }\n\n    /// @dev Unchecked arithmetic for subtracting two numbers.\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }\n\n    /// @dev Returns the offsetted timestamp.\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }\n}\n"}},"settings":{"remappings":["solady/=lib/solady/src/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":999999},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
